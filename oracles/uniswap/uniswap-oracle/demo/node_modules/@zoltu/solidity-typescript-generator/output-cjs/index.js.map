{"version":3,"file":"index.js","sourceRoot":"","sources":["../source/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { generateFullSignature, AbiDescription, EventDescription, FunctionDescription, ParameterDescription, EventParameterDescription } from '@zoltu/ethereum-abi-encoder'\nimport { keccak256 } from '@zoltu/ethereum-crypto'\n\ntype Abi = ReadonlyArray<AbiDescription>\n\nexport interface CompilerOutput {\n\treadonly contracts: {\n\t\t[globalName: string]: {\n\t\t\t[contractName: string]: {\n\t\t\t\treadonly abi: Abi\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport async function generateContractInterfaces(contractsOutput: Readonly<CompilerOutput>): Promise<string> {\n\tconst contractInterfaces: Array<string> = []\n\tconst eventDescriptions: Map<string, string> = new Map<string, string>()\n\tconst eventInterfaces: Array<string> = []\n\tconst eventTypes: Array<string> = []\n\n\tconst duplicateCounters: Record<string, number> = {}\n\tfor (let globalName in contractsOutput.contracts) {\n\t\tfor (let contractName in contractsOutput.contracts[globalName]) {\n\t\t\tconst contractAbi: Abi = contractsOutput.contracts[globalName][contractName].abi\n\t\t\tif (contractAbi.length == 0) continue\n\t\t\tduplicateCounters[contractName] = (duplicateCounters[contractName] || 0) + 1\n\t\t\tconst contractNameSuffix = duplicateCounters[contractName] === 1 ? '' : duplicateCounters[contractName]\n\t\t\tcontractInterfaces.push(contractInterfaceTemplate(`${contractName}${contractNameSuffix}`, contractAbi))\n\t\t\tfor (let abiEvent of contractAbi.filter(abiEntry => abiEntry.type === 'event').map(abiEntry => <EventDescription>abiEntry).filter(abiEvent => abiEvent.name)) {\n\t\t\t\tconst eventDescription = await eventDescriptionTemplate(abiEvent)\n\t\t\t\teventDescriptions.set(eventDescription.substring(1, 65), eventDescription)\n\t\t\t\tconst eventInterface = eventInterfaceTemplate(contractName, abiEvent)\n\t\t\t\teventInterfaces.push(eventInterface)\n\t\t\t\teventTypes.push(`${contractName}.${abiEvent.name}`)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn `// THIS FILE IS AUTOMATICALLY GENERATED BY \\`generateContractInterfaces.ts\\`. DO NOT EDIT BY HAND'\n\nimport { EventDescription, DecodedEvent, ParameterDescription, EncodableArray, EncodableTuple, decodeParameters, decodeEvent, decodeMethod } from '@zoltu/ethereum-abi-encoder'\nexport { EncodableArray, EncodableTuple }\n\nexport interface Log {\n\treadonly topics: ReadonlyArray<bigint>\n\treadonly data: Uint8Array\n}\nexport interface TransactionReceipt {\n\treadonly status: boolean\n\treadonly logs: Iterable<Log>\n}\n\nexport const eventDescriptions: { [signatureHash: string]: EventDescription & {signature: string} } = {\n${Array.of(...eventDescriptions.values()).map(x => `\\t${x}`).join(',\\n')}\n}\n\n${eventInterfaces.join('\\n\\n')}\n\nexport type Event = DecodedEvent${eventTypes.length !== 0 ? ' | ': ''}${eventTypes.join(' | ')}\n\n\nexport interface Dependencies {\n\tcall(address: bigint, methodSignature: string, methodParameters: EncodableArray, value: bigint): Promise<Uint8Array>\n\tsubmitTransaction(address: bigint, methodSignature: string, methodParameters: EncodableArray, value: bigint): Promise<TransactionReceipt>\n}\n\n\n/**\n * By convention, pure/view methods have a \\`_\\` suffix on them indicating to the caller that the function will be executed locally and return the function's result.  payable/nonpayable functions have both a local version and a remote version (distinguished by the trailing \\`_\\`).  If the remote method is called, you will only get back a transaction hash which can be used to lookup the transaction receipt for success/failure (due to EVM limitations you will not get the function results back).\n */\nexport class Contract {\n\tprotected constructor(protected readonly dependencies: Dependencies, public readonly address: bigint) { }\n\n\tprotected async localCall(methodSignature: string, outputParameterDescriptions: ReadonlyArray<ParameterDescription>, methodParameters: EncodableArray, attachedEth?: bigint): Promise<EncodableTuple> {\n\t\tconst result = await this.dependencies.call(this.address, methodSignature, methodParameters, attachedEth || 0n)\n\t\tif (result.length >= 4 && result[0] === 8 && result[1] === 195 && result[2] === 121 && result[3] === 160) {\n\t\t\tconst decodedError = decodeMethod(0x08c379a0, [ { name: 'message', type: 'string' } ], result) as { message: string }\n\t\t\tthrow new Error(\\`Contract Error: \\${decodedError.message}\\`)\n\t\t}\n\t\treturn decodeParameters(outputParameterDescriptions, result)\n\t}\n\n\tprotected async remoteCall(methodSignature: string, parameters: EncodableArray, errorContext: { transactionName: string }, attachedEth?: bigint): Promise<Array<Event>> {\n\t\tconst transactionReceipt = await this.dependencies.submitTransaction(this.address, methodSignature, parameters, attachedEth || 0n)\n\t\tif (!transactionReceipt.status) throw new Error(\\`Remote call of \\${errorContext.transactionName} failed: \\${JSON.stringify(transactionReceipt)}\\`)\n\t\treturn this.decodeEvents(transactionReceipt.logs)\n\t}\n\n\tprivate decodeEvents(encodedEvents: Iterable<Log>): Array<Event> {\n\t\tconst decodedEvents: Array<DecodedEvent> = []\n\t\tfor (const encodedEvent of encodedEvents) {\n\t\t\tconst decodedEvent = this.tryDecodeEvent(encodedEvent)\n\t\t\tif (decodedEvent) decodedEvents.push(decodedEvent)\n\t\t}\n\t\treturn decodedEvents as Array<Event>\n\t}\n\n\tprivate tryDecodeEvent(encodedEvent: Log): DecodedEvent | null {\n\t\tconst signatureHash = encodedEvent.topics[0]\n\t\tconst eventDescription = eventDescriptions[signatureHash.toString(16)]\n\t\tif (!eventDescription) return null\n\t\treturn decodeEvent(eventDescription, encodedEvent.topics, encodedEvent.data)\n\t}\n}\n\n${contractInterfaces.join('\\n')}`\n}\n\nfunction contractInterfaceTemplate(contractName: string, contractAbi: Abi) {\n\tconst contractMethods: Array<string> = []\n\n\t// FIXME: Add support for Solidity function overloads.  Right now overloaded functions are not supported, only the first one seen will survive addition into the following set.\n\tconst seenCount: Record<string, number> = {}\n\n\tconst contractFunctions: Array<FunctionDescription> = contractAbi\n\t\t.filter(abiEntry => abiEntry.type == 'function')\n\t\t.map(abiFunction => <FunctionDescription>abiFunction)\n\n\tfor (let abiFunction of contractFunctions) {\n\t\tseenCount[abiFunction.name] = (seenCount[abiFunction.name] || 0) + 1\n\t\tconst functionName = (seenCount[abiFunction.name] !== 1) ? `${abiFunction.name}${seenCount[abiFunction.name]}` : abiFunction.name\n\t\tif (abiFunction.stateMutability !== 'pure' && abiFunction.stateMutability !== 'view') {\n\t\t\tcontractMethods.push(remoteMethodTemplate(functionName, abiFunction, { contractName: contractName}))\n\t\t}\n\t\tcontractMethods.push(localMethodTemplate(functionName, abiFunction, { contractName: contractName}))\n\t}\n\n\treturn `\nexport class ${contractName} extends Contract {\n\tpublic constructor(dependencies: Dependencies, address: bigint) {\n\t\tsuper(dependencies, address)\n\t}\n\n${contractMethods.join('\\n\\n')}\n}\n`\n}\n\nasync function eventDescriptionTemplate(abiEvent: EventDescription): Promise<string> {\n\tconst signature = toSignature(abiEvent.name, abiEvent.inputs)\n\tconst signatureHash = await keccak256.hash(new TextEncoder().encode(signature))\n\tconst eventDescription = {\n\t\ttype: 'event',\n\t\tname: abiEvent.name,\n\t\tsignature: signature,\n\t\tinputs: abiEvent.inputs.map(scrubParameterDescription),\n\t}\n\treturn `'${signatureHash.toString(16)}': ${JSON.stringify(eventDescription)}`\n}\n\nfunction scrubParameterDescription(parameterDescription: ParameterDescription): ParameterDescription {\n\treturn {\n\t\ttype: parameterDescription.type,\n\t\tname: parameterDescription.name,\n\t\t...( 'components' in parameterDescription ? { components: (parameterDescription.components || []).map(scrubParameterDescription) } : {}),\n\t\t...('indexed' in parameterDescription ? { indexed: (parameterDescription as EventParameterDescription).indexed } : {})\n\t}\n}\n\nfunction eventInterfaceTemplate(contractName: string, abiEvent: EventDescription): string {\n\treturn `export namespace ${contractName} {\n\texport interface ${abiEvent.name} extends DecodedEvent {\n\t\tname: '${abiEvent.name}'\n\t\tparameters: {\n${\n\tabiEvent.inputs\n\t\t.map(parameter => (parameter.indexed && parameter.type === 'string') ? { ...parameter, type: 'bytes32' } : parameter)\n\t\t.map(input => `\\t\\t\\t${input.name}: ${toTsTypeString(input, false, { contractName: contractName, functionName: abiEvent.name })}`).join('\\n')\n}\n\t\t}\n\t}\n}`\n}\n\nfunction remoteMethodTemplate(functionName: string, abiFunction: FunctionDescription, errorContext: { contractName: string }) {\n\tconst argNames: string = toArgNameString(abiFunction)\n\tconst params: string = toParamsString(abiFunction, true, errorContext)\n\tconst methodSignature = generateFullSignature(abiFunction)\n\tconst separator = (abiFunction.inputs.length !== 0 && abiFunction.stateMutability === 'payable') ? ', ' : ''\n\tconst attachedEthInputParameter = (abiFunction.stateMutability === 'payable') ? 'attachedEth?: bigint' : ''\n\tconst attachedEthCallParameter = (abiFunction.stateMutability === 'payable') ? ', attachedEth' : ''\n\treturn `\tpublic ${functionName} = async (${params}${separator}${attachedEthInputParameter}): Promise<Array<Event>> => {\n\t\tconst methodSignature = '${methodSignature}' as const\n\t\tconst methodParameters = [${argNames}] as const\n\t\treturn await this.remoteCall(methodSignature, methodParameters, { transactionName: '${abiFunction.name}' }${attachedEthCallParameter})\n\t}`\n}\n\nfunction localMethodTemplate(functionName: string, abiFunction: FunctionDescription, errorContext: { contractName: string }) {\n\tconst outputs = abiFunction.outputs || []\n\tconst argNames: string = toArgNameString(abiFunction)\n\tconst params: string = toParamsString(abiFunction, true, errorContext)\n\tconst methodSignature = generateFullSignature(abiFunction)\n\tconst separator = (abiFunction.inputs.length !== 0 && (abiFunction.stateMutability === 'payable')) ? ', ' : ''\n\tconst attachedEthInputParameter = (abiFunction.stateMutability === 'payable') ? 'attachedEth?: bigint' : ''\n\tconst attachedEthCallParameter = (abiFunction.stateMutability === 'payable') ? ', attachedEth' : ''\n\tconst returnType: string = toTsReturnTypeString(outputs, { contractName: errorContext.contractName, functionName: abiFunction.name })\n\tconst returnValue: string = (outputs.length === 1)\n\t\t? `<${returnType}>result.${outputs[0].name || 'result'}`\n\t\t: `<${returnType}>result`\n\treturn `\tpublic ${functionName}_ = async (${params}${separator}${attachedEthInputParameter}): Promise<${returnType}> => {\n\t\tconst methodSignature = '${methodSignature}' as const\n\t\tconst methodParameters = [${argNames}] as const\n\t\tconst outputParameterDescriptions = ${JSON.stringify(abiFunction.outputs)} as const\n\t\t${outputs.length !== 0 ? 'const result = ' : ''}await this.localCall(methodSignature, outputParameterDescriptions, methodParameters${attachedEthCallParameter})${outputs.length !== 0 ? `\\n\\t\\treturn ${returnValue}` : ''}\n\t}`\n}\n\nfunction toTsReturnTypeString(abiParameters: ReadonlyArray<ParameterDescription>, errorContext: { contractName: string, functionName: string }): string {\n\tif (abiParameters.length === 0) return `void`\n\telse if (abiParameters.length === 1) return toTsTypeString(abiParameters[0], false, errorContext)\n\telse if (!abiParameters.every(abiParameter => !!abiParameter.name)) throw new Error(`Function ${errorContext.contractName}.${errorContext.functionName} has multiple return values but not all are named.`)\n\telse return `{${abiParameters.map(abiParameter => `${abiParameter.name}: ${toTsTypeString(abiParameter, false, errorContext)}`).join(', ')}}`\n}\n\nfunction toTsTypeString(abiParameter: ParameterDescription, readonly: boolean, errorContext: { contractName: string, functionName: string }): string {\n\tif (/^u?int(\\d*)$/.test(abiParameter.type)) {\n\t\treturn `bigint`\n\t} else if (/^address$/.test(abiParameter.type)) {\n\t\treturn 'bigint'\n\t} else if (/^bool$/.test(abiParameter.type)) {\n\t\treturn 'boolean'\n\t} else if (/^bytes\\d+$/.test(abiParameter.type)) {\n\t\treturn `bigint`\n\t} else if (/^string$/.test(abiParameter.type)) {\n\t\treturn 'string'\n\t} else if (/^bytes$/.test(abiParameter.type)) {\n\t\treturn 'Uint8Array'\n\t} else if (/^.*?\\[\\d*\\]$/.test(abiParameter.type)) {\n\t\tconst nestedParameterDescription = Object.assign({}, abiParameter, { type: /^(.*?)\\[\\d*\\]$/.exec(abiParameter.type)![1] })\n\t\treturn `${readonly ? 'Readonly' : ''}Array<${toTsTypeString(nestedParameterDescription, readonly, errorContext)}>`\n\t} else if (/^tuple$/.test(abiParameter.type)) {\n\t\treturn `{ ${abiParameter.components!.map(component => `${readonly ? 'readonly ' : ''}${component.name}: ${toTsTypeString(component, readonly, errorContext)}`).join(', ')} }`\n\t} else if (/^u?fixed\\d+x\\d+$/.test(abiParameter.type)) {\n\t\tthrow new Error(`fixed point parameters are not supported`)\n\t} else if (/^function$/.test(abiParameter.type)) {\n\t\tthrow new Error(`function parameters are not supported`)\n\t} else {\n\t\tthrow new Error(`Unrecognized parameter type in ${errorContext.contractName}.${errorContext.functionName}: ${JSON.stringify(abiParameter)}`)\n\t}\n}\n\nfunction toArgNameString(abiFunction: FunctionDescription) {\n\treturn abiFunction.inputs.map(toParamNameString).join(', ')\n}\n\nfunction toParamsString(abiFunction: FunctionDescription, readonly: boolean, errorContext: { contractName: string }) {\n\tif (abiFunction.inputs.length == 0) return ''\n\treturn abiFunction.inputs.map((abiParameter, i) => `${toParamNameString(abiParameter, i)}: ${toTsTypeString(abiParameter, readonly, { contractName: errorContext.contractName, functionName: abiFunction.name })}`).join(', ')\n}\n\nfunction toParamNameString(abiParameter: ParameterDescription, index: number) {\n\tif (!abiParameter.name) return `arg${index}`\n\telse if (abiParameter.name.startsWith('_')) return abiParameter.name.substr(1)\n\telse return abiParameter.name\n}\n\nfunction toSignature(name: string, params: ReadonlyArray<ParameterDescription>): string {\n\tconst parameters = stringifyParamsForSignature(params).join(',')\n\treturn `${name}(${parameters})`\n}\n\nfunction stringifyParamsForSignature(params: ReadonlyArray<ParameterDescription>): Array<string> {\n\treturn params.map(param => {\n\t\tif (param.type === 'tuple') {\n\t\t\tif (!param.components) throw new Error(`Expected components when type is ${param.type}`)\n\t\t\treturn `(${stringifyParamsForSignature(param.components).join(',')})`\n\t\t} else if (param.type === 'tuple[]') {\n\t\t\tif (!param.components) throw new Error(`Expected components when type is ${param.type}`)\n\t\t\treturn `(${stringifyParamsForSignature(param.components).join(',')})[]`\n\t\t} else {\n\t\t\treturn param.type\n\t\t}\n\t})\n}\n\n// https://github.com/microsoft/TypeScript/issues/31535\ninterface TextEncoder {\n\t/** Returns \"utf-8\". */\n\treadonly encoding: string\n\t/** Returns the result of running UTF-8's encoder. */\n\tencode(input?: string): Uint8Array\n}\ndeclare var TextEncoder: { prototype: TextEncoder; new(): TextEncoder }\n"]}