"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateContractInterfaces = void 0;
const ethereum_abi_encoder_1 = require("@zoltu/ethereum-abi-encoder");
const ethereum_crypto_1 = require("@zoltu/ethereum-crypto");
async function generateContractInterfaces(contractsOutput) {
    const contractInterfaces = [];
    const eventDescriptions = new Map();
    const eventInterfaces = [];
    const eventTypes = [];
    const duplicateCounters = {};
    for (let globalName in contractsOutput.contracts) {
        for (let contractName in contractsOutput.contracts[globalName]) {
            const contractAbi = contractsOutput.contracts[globalName][contractName].abi;
            if (contractAbi.length == 0)
                continue;
            duplicateCounters[contractName] = (duplicateCounters[contractName] || 0) + 1;
            const contractNameSuffix = duplicateCounters[contractName] === 1 ? '' : duplicateCounters[contractName];
            contractInterfaces.push(contractInterfaceTemplate(`${contractName}${contractNameSuffix}`, contractAbi));
            for (let abiEvent of contractAbi.filter(abiEntry => abiEntry.type === 'event').map(abiEntry => abiEntry).filter(abiEvent => abiEvent.name)) {
                const eventDescription = await eventDescriptionTemplate(abiEvent);
                eventDescriptions.set(eventDescription.substring(1, 65), eventDescription);
                const eventInterface = eventInterfaceTemplate(contractName, abiEvent);
                eventInterfaces.push(eventInterface);
                eventTypes.push(`${contractName}.${abiEvent.name}`);
            }
        }
    }
    return `// THIS FILE IS AUTOMATICALLY GENERATED BY \`generateContractInterfaces.ts\`. DO NOT EDIT BY HAND'

import { EventDescription, DecodedEvent, ParameterDescription, EncodableArray, EncodableTuple, decodeParameters, decodeEvent, decodeMethod } from '@zoltu/ethereum-abi-encoder'
export { EncodableArray, EncodableTuple }

export interface Log {
	readonly topics: ReadonlyArray<bigint>
	readonly data: Uint8Array
}
export interface TransactionReceipt {
	readonly status: boolean
	readonly logs: Iterable<Log>
}

export const eventDescriptions: { [signatureHash: string]: EventDescription & {signature: string} } = {
${Array.of(...eventDescriptions.values()).map(x => `\t${x}`).join(',\n')}
}

${eventInterfaces.join('\n\n')}

export type Event = DecodedEvent${eventTypes.length !== 0 ? ' | ' : ''}${eventTypes.join(' | ')}


export interface Dependencies {
	call(address: bigint, methodSignature: string, methodParameters: EncodableArray, value: bigint): Promise<Uint8Array>
	submitTransaction(address: bigint, methodSignature: string, methodParameters: EncodableArray, value: bigint): Promise<TransactionReceipt>
}


/**
 * By convention, pure/view methods have a \`_\` suffix on them indicating to the caller that the function will be executed locally and return the function's result.  payable/nonpayable functions have both a local version and a remote version (distinguished by the trailing \`_\`).  If the remote method is called, you will only get back a transaction hash which can be used to lookup the transaction receipt for success/failure (due to EVM limitations you will not get the function results back).
 */
export class Contract {
	protected constructor(protected readonly dependencies: Dependencies, public readonly address: bigint) { }

	protected async localCall(methodSignature: string, outputParameterDescriptions: ReadonlyArray<ParameterDescription>, methodParameters: EncodableArray, attachedEth?: bigint): Promise<EncodableTuple> {
		const result = await this.dependencies.call(this.address, methodSignature, methodParameters, attachedEth || 0n)
		if (result.length >= 4 && result[0] === 8 && result[1] === 195 && result[2] === 121 && result[3] === 160) {
			const decodedError = decodeMethod(0x08c379a0, [ { name: 'message', type: 'string' } ], result) as { message: string }
			throw new Error(\`Contract Error: \${decodedError.message}\`)
		}
		return decodeParameters(outputParameterDescriptions, result)
	}

	protected async remoteCall(methodSignature: string, parameters: EncodableArray, errorContext: { transactionName: string }, attachedEth?: bigint): Promise<Array<Event>> {
		const transactionReceipt = await this.dependencies.submitTransaction(this.address, methodSignature, parameters, attachedEth || 0n)
		if (!transactionReceipt.status) throw new Error(\`Remote call of \${errorContext.transactionName} failed: \${JSON.stringify(transactionReceipt)}\`)
		return this.decodeEvents(transactionReceipt.logs)
	}

	private decodeEvents(encodedEvents: Iterable<Log>): Array<Event> {
		const decodedEvents: Array<DecodedEvent> = []
		for (const encodedEvent of encodedEvents) {
			const decodedEvent = this.tryDecodeEvent(encodedEvent)
			if (decodedEvent) decodedEvents.push(decodedEvent)
		}
		return decodedEvents as Array<Event>
	}

	private tryDecodeEvent(encodedEvent: Log): DecodedEvent | null {
		const signatureHash = encodedEvent.topics[0]
		const eventDescription = eventDescriptions[signatureHash.toString(16)]
		if (!eventDescription) return null
		return decodeEvent(eventDescription, encodedEvent.topics, encodedEvent.data)
	}
}

${contractInterfaces.join('\n')}`;
}
exports.generateContractInterfaces = generateContractInterfaces;
function contractInterfaceTemplate(contractName, contractAbi) {
    const contractMethods = [];
    // FIXME: Add support for Solidity function overloads.  Right now overloaded functions are not supported, only the first one seen will survive addition into the following set.
    const seenCount = {};
    const contractFunctions = contractAbi
        .filter(abiEntry => abiEntry.type == 'function')
        .map(abiFunction => abiFunction);
    for (let abiFunction of contractFunctions) {
        seenCount[abiFunction.name] = (seenCount[abiFunction.name] || 0) + 1;
        const functionName = (seenCount[abiFunction.name] !== 1) ? `${abiFunction.name}${seenCount[abiFunction.name]}` : abiFunction.name;
        if (abiFunction.stateMutability !== 'pure' && abiFunction.stateMutability !== 'view') {
            contractMethods.push(remoteMethodTemplate(functionName, abiFunction, { contractName: contractName }));
        }
        contractMethods.push(localMethodTemplate(functionName, abiFunction, { contractName: contractName }));
    }
    return `
export class ${contractName} extends Contract {
	public constructor(dependencies: Dependencies, address: bigint) {
		super(dependencies, address)
	}

${contractMethods.join('\n\n')}
}
`;
}
async function eventDescriptionTemplate(abiEvent) {
    const signature = toSignature(abiEvent.name, abiEvent.inputs);
    const signatureHash = await ethereum_crypto_1.keccak256.hash(new TextEncoder().encode(signature));
    const eventDescription = {
        type: 'event',
        name: abiEvent.name,
        signature: signature,
        inputs: abiEvent.inputs.map(scrubParameterDescription),
    };
    return `'${signatureHash.toString(16)}': ${JSON.stringify(eventDescription)}`;
}
function scrubParameterDescription(parameterDescription) {
    return {
        type: parameterDescription.type,
        name: parameterDescription.name,
        ...('components' in parameterDescription ? { components: (parameterDescription.components || []).map(scrubParameterDescription) } : {}),
        ...('indexed' in parameterDescription ? { indexed: parameterDescription.indexed } : {})
    };
}
function eventInterfaceTemplate(contractName, abiEvent) {
    return `export namespace ${contractName} {
	export interface ${abiEvent.name} extends DecodedEvent {
		name: '${abiEvent.name}'
		parameters: {
${abiEvent.inputs
        .map(parameter => (parameter.indexed && parameter.type === 'string') ? { ...parameter, type: 'bytes32' } : parameter)
        .map(input => `\t\t\t${input.name}: ${toTsTypeString(input, false, { contractName: contractName, functionName: abiEvent.name })}`).join('\n')}
		}
	}
}`;
}
function remoteMethodTemplate(functionName, abiFunction, errorContext) {
    const argNames = toArgNameString(abiFunction);
    const params = toParamsString(abiFunction, true, errorContext);
    const methodSignature = ethereum_abi_encoder_1.generateFullSignature(abiFunction);
    const separator = (abiFunction.inputs.length !== 0 && abiFunction.stateMutability === 'payable') ? ', ' : '';
    const attachedEthInputParameter = (abiFunction.stateMutability === 'payable') ? 'attachedEth?: bigint' : '';
    const attachedEthCallParameter = (abiFunction.stateMutability === 'payable') ? ', attachedEth' : '';
    return `	public ${functionName} = async (${params}${separator}${attachedEthInputParameter}): Promise<Array<Event>> => {
		const methodSignature = '${methodSignature}' as const
		const methodParameters = [${argNames}] as const
		return await this.remoteCall(methodSignature, methodParameters, { transactionName: '${abiFunction.name}' }${attachedEthCallParameter})
	}`;
}
function localMethodTemplate(functionName, abiFunction, errorContext) {
    const outputs = abiFunction.outputs || [];
    const argNames = toArgNameString(abiFunction);
    const params = toParamsString(abiFunction, true, errorContext);
    const methodSignature = ethereum_abi_encoder_1.generateFullSignature(abiFunction);
    const separator = (abiFunction.inputs.length !== 0 && (abiFunction.stateMutability === 'payable')) ? ', ' : '';
    const attachedEthInputParameter = (abiFunction.stateMutability === 'payable') ? 'attachedEth?: bigint' : '';
    const attachedEthCallParameter = (abiFunction.stateMutability === 'payable') ? ', attachedEth' : '';
    const returnType = toTsReturnTypeString(outputs, { contractName: errorContext.contractName, functionName: abiFunction.name });
    const returnValue = (outputs.length === 1)
        ? `<${returnType}>result.${outputs[0].name || 'result'}`
        : `<${returnType}>result`;
    return `	public ${functionName}_ = async (${params}${separator}${attachedEthInputParameter}): Promise<${returnType}> => {
		const methodSignature = '${methodSignature}' as const
		const methodParameters = [${argNames}] as const
		const outputParameterDescriptions = ${JSON.stringify(abiFunction.outputs)} as const
		${outputs.length !== 0 ? 'const result = ' : ''}await this.localCall(methodSignature, outputParameterDescriptions, methodParameters${attachedEthCallParameter})${outputs.length !== 0 ? `\n\t\treturn ${returnValue}` : ''}
	}`;
}
function toTsReturnTypeString(abiParameters, errorContext) {
    if (abiParameters.length === 0)
        return `void`;
    else if (abiParameters.length === 1)
        return toTsTypeString(abiParameters[0], false, errorContext);
    else if (!abiParameters.every(abiParameter => !!abiParameter.name))
        throw new Error(`Function ${errorContext.contractName}.${errorContext.functionName} has multiple return values but not all are named.`);
    else
        return `{${abiParameters.map(abiParameter => `${abiParameter.name}: ${toTsTypeString(abiParameter, false, errorContext)}`).join(', ')}}`;
}
function toTsTypeString(abiParameter, readonly, errorContext) {
    if (/^u?int(\d*)$/.test(abiParameter.type)) {
        return `bigint`;
    }
    else if (/^address$/.test(abiParameter.type)) {
        return 'bigint';
    }
    else if (/^bool$/.test(abiParameter.type)) {
        return 'boolean';
    }
    else if (/^bytes\d+$/.test(abiParameter.type)) {
        return `bigint`;
    }
    else if (/^string$/.test(abiParameter.type)) {
        return 'string';
    }
    else if (/^bytes$/.test(abiParameter.type)) {
        return 'Uint8Array';
    }
    else if (/^.*?\[\d*\]$/.test(abiParameter.type)) {
        const nestedParameterDescription = Object.assign({}, abiParameter, { type: /^(.*?)\[\d*\]$/.exec(abiParameter.type)[1] });
        return `${readonly ? 'Readonly' : ''}Array<${toTsTypeString(nestedParameterDescription, readonly, errorContext)}>`;
    }
    else if (/^tuple$/.test(abiParameter.type)) {
        return `{ ${abiParameter.components.map(component => `${readonly ? 'readonly ' : ''}${component.name}: ${toTsTypeString(component, readonly, errorContext)}`).join(', ')} }`;
    }
    else if (/^u?fixed\d+x\d+$/.test(abiParameter.type)) {
        throw new Error(`fixed point parameters are not supported`);
    }
    else if (/^function$/.test(abiParameter.type)) {
        throw new Error(`function parameters are not supported`);
    }
    else {
        throw new Error(`Unrecognized parameter type in ${errorContext.contractName}.${errorContext.functionName}: ${JSON.stringify(abiParameter)}`);
    }
}
function toArgNameString(abiFunction) {
    return abiFunction.inputs.map(toParamNameString).join(', ');
}
function toParamsString(abiFunction, readonly, errorContext) {
    if (abiFunction.inputs.length == 0)
        return '';
    return abiFunction.inputs.map((abiParameter, i) => `${toParamNameString(abiParameter, i)}: ${toTsTypeString(abiParameter, readonly, { contractName: errorContext.contractName, functionName: abiFunction.name })}`).join(', ');
}
function toParamNameString(abiParameter, index) {
    if (!abiParameter.name)
        return `arg${index}`;
    else if (abiParameter.name.startsWith('_'))
        return abiParameter.name.substr(1);
    else
        return abiParameter.name;
}
function toSignature(name, params) {
    const parameters = stringifyParamsForSignature(params).join(',');
    return `${name}(${parameters})`;
}
function stringifyParamsForSignature(params) {
    return params.map(param => {
        if (param.type === 'tuple') {
            if (!param.components)
                throw new Error(`Expected components when type is ${param.type}`);
            return `(${stringifyParamsForSignature(param.components).join(',')})`;
        }
        else if (param.type === 'tuple[]') {
            if (!param.components)
                throw new Error(`Expected components when type is ${param.type}`);
            return `(${stringifyParamsForSignature(param.components).join(',')})[]`;
        }
        else {
            return param.type;
        }
    });
}
//# sourceMappingURL=index.js.map