import { Bytes, Rpc, isJsonRpcError, validateJsonRpcResponse } from '@zoltu/ethereum-types';
import { rlpEncode } from "./vendor/rlp-encoder/index.js";
import { ErrorWithData } from "./error-with-data.js";
export { ErrorWithData };
import { sleep } from "./sleep.js";
import { stripLeadingZeros } from "./utils.js";
export class FetchJsonRpc {
    constructor(jsonRpcEndpoint, fetch, options) {
        this.jsonRpcEndpoint = jsonRpcEndpoint;
        this.fetch = fetch;
        this.sendEth = async (destination, amount) => await this.executeTransaction({ to: destination, value: amount });
        this.deployContract = async (bytecode, value) => (await this.executeTransaction({ to: null, data: bytecode, value: value })).contractAddress;
        this.onChainContractCall = async (transaction) => this.executeTransaction(transaction);
        this.offChainContractCall = async (transaction) => {
            const offChainTransaction = {
                from: transaction.from !== undefined ? transaction.from : await this.coinbase().catch(() => null) || 0n,
                to: transaction.to,
                value: transaction.value || 0n,
                data: transaction.data || new Bytes(),
                gasLimit: transaction.gasLimit || 1000000000n,
                gasPrice: transaction.gasPrice || await this.getGasPrice(),
            };
            return await this.call(offChainTransaction);
        };
        this.executeTransaction = async (transaction) => {
            const transactionHash = await this.submitTransaction(transaction);
            let receipt = await this.getTransactionReceipt(transactionHash);
            // TODO: find out if Parity, Geth or MM return a receipt with a null block anymore (docs suggest no)
            while (receipt === null || receipt.blockNumber === null) {
                await sleep(1000);
                receipt = await this.getTransactionReceipt(transactionHash);
            }
            if (!receipt.status)
                throw new Error(`Transaction mined, but failed.`);
            if (!receipt.contractAddress && !transaction.to)
                throw new Error(`Contract deployment failed.  Contract address was null.`);
            return receipt;
        };
        this.submitTransaction = async (transaction) => {
            const { encodedTransaction } = await this.signTransaction(transaction);
            return await this.sendRawTransaction(encodedTransaction);
        };
        this.makeRequest = (Request, Response) => async (...args) => {
            const request = new Request(0, ...args);
            const rawRequest = request.wireEncode();
            const rawResponse = await this.remoteProcedureCall(rawRequest);
            const response = new Response(rawResponse);
            return response.result;
        };
        this.call = this.makeRequest(Rpc.Eth.Call.Request, Rpc.Eth.Call.Response);
        this.estimateGas = this.makeRequest(Rpc.Eth.EstimateGas.Request, Rpc.Eth.EstimateGas.Response);
        this.getBalance = this.makeRequest(Rpc.Eth.GetBalance.Request, Rpc.Eth.GetBalance.Response);
        this.getBlockByHash = this.makeRequest(Rpc.Eth.GetBlockByHash.Request, Rpc.Eth.GetBlockByHash.Response);
        this.getBlockByNumber = this.makeRequest(Rpc.Eth.GetBlockByNumber.Request, Rpc.Eth.GetBlockByNumber.Response);
        this.getBlockNumber = this.makeRequest(Rpc.Eth.BlockNumber.Request, Rpc.Eth.BlockNumber.Response);
        this.getBlockTransactionCountByHash = this.makeRequest(Rpc.Eth.GetBlockTransactionCountByHash.Request, Rpc.Eth.GetBlockTransactionCountByHash.Response);
        this.getBlockTransactionCountByNumber = this.makeRequest(Rpc.Eth.GetBlockTransactionCountByNumber.Request, Rpc.Eth.GetBlockTransactionCountByNumber.Response);
        this.getChainId = this.makeRequest(Rpc.Eth.ChainId.Request, Rpc.Eth.ChainId.Response);
        this.getCode = this.makeRequest(Rpc.Eth.GetCode.Request, Rpc.Eth.GetCode.Response);
        this.getLogs = this.makeRequest(Rpc.Eth.GetLogs.Request, Rpc.Eth.GetLogs.Response);
        this.getProof = this.makeRequest(Rpc.Eth.GetProof.Request, Rpc.Eth.GetProof.Response);
        this.getStorageAt = this.makeRequest(Rpc.Eth.GetStorageAt.Request, Rpc.Eth.GetStorageAt.Response);
        this.getTransactionByBlockHashAndIndex = this.makeRequest(Rpc.Eth.GetTransactionByBlockHashAndIndex.Request, Rpc.Eth.GetTransactionByBlockHashAndIndex.Response);
        this.getTransactionByBlockNumberAndIndex = this.makeRequest(Rpc.Eth.GetTransactionByBlockNumberAndIndex.Request, Rpc.Eth.GetTransactionByBlockNumberAndIndex.Response);
        this.getTransactionByHash = this.makeRequest(Rpc.Eth.GetTransactionByHash.Request, Rpc.Eth.GetTransactionByHash.Response);
        this.getTransactionCount = this.makeRequest(Rpc.Eth.GetTransactionCount.Request, Rpc.Eth.GetTransactionCount.Response);
        // workaround for Parity returning partial transaction receipts before mining
        // public readonly getTransactionReceipt = this.makeRequest(Rpc.Eth.GetTransactionReceipt.Request, Rpc.Eth.GetTransactionReceipt.Response)
        this.getTransactionReceipt = async (transactionHash) => {
            const request = new Rpc.Eth.GetTransactionReceipt.Request(null, transactionHash);
            const rawRequest = request.wireEncode();
            const rawResponse = await this.remoteProcedureCall(rawRequest);
            if (rawResponse.result === null || rawResponse.result.blockNumber === null || rawResponse.result.blockHash === null)
                return null;
            const response = new Rpc.Eth.GetTransactionReceipt.Response(rawResponse);
            return response.result;
        };
        this.getUncleByBlockHashAndIndex = this.makeRequest(Rpc.Eth.GetUncleByBlockHashAndIndex.Request, Rpc.Eth.GetUncleByBlockHashAndIndex.Response);
        this.getUncleByBlockNumberAndIndex = this.makeRequest(Rpc.Eth.GetUncleByBlockNumberAndIndex.Request, Rpc.Eth.GetUncleByBlockNumberAndIndex.Response);
        this.getUncleCountByBlockHash = this.makeRequest(Rpc.Eth.GetUncleCountByBlockHash.Request, Rpc.Eth.GetUncleCountByBlockHash.Response);
        this.getUncleCountByBlockNumber = this.makeRequest(Rpc.Eth.GetUncleCountByBlockNumber.Request, Rpc.Eth.GetUncleCountByBlockNumber.Response);
        this.getProtocolVersion = this.makeRequest(Rpc.Eth.ProtocolVersion.Request, Rpc.Eth.ProtocolVersion.Response);
        this.sendRawTransaction = this.makeRequest(Rpc.Eth.SendRawTransaction.Request, Rpc.Eth.SendRawTransaction.Response);
        this.sendTransaction = this.submitTransaction;
        this.signTransaction = async (transaction) => {
            const gasEstimatingTransaction = {
                from: transaction.from !== undefined ? transaction.from : await this.coinbase().catch(() => null) || 0n,
                to: transaction.to,
                value: transaction.value || 0n,
                data: transaction.data || new Bytes(),
                gasLimit: transaction.gasLimit || 1000000000n,
                gasPrice: transaction.gasPrice || await this.getGasPrice(),
            };
            const unsignedTransaction = {
                ...gasEstimatingTransaction,
                gasLimit: transaction.gasLimit || await this.gasLimitProvider(gasEstimatingTransaction, this.estimateGas),
                nonce: transaction.nonce || await this.getTransactionCount(gasEstimatingTransaction.from, 'pending'),
                chainId: await this.chainId,
            };
            if (this.signatureProvider === undefined) {
                return await this.makeRequest(Rpc.Eth.SignTransaction.Request, Rpc.Eth.SignTransaction.Response)(unsignedTransaction);
            }
            else {
                const rlpEncodedUnsignedTransaction = this.rlpEncodeTransaction(unsignedTransaction);
                const signature = await this.signatureProvider(rlpEncodedUnsignedTransaction);
                const v = (signature.yParity === 'even' ? 0n : 1n) + 35n + 2n * unsignedTransaction.chainId;
                const decodedTransaction = { ...unsignedTransaction, r: signature.r, s: signature.s, v };
                const encodedTransaction = this.rlpEncodeTransaction(decodedTransaction);
                return { decodedTransaction, encodedTransaction };
            }
        };
        this.sign = async (signerAddress, data) => {
            if (this.signatureProvider === undefined)
                return this.makeRequest(Rpc.Eth.Sign.Request, Rpc.Eth.Sign.Response)(signerAddress, data);
            if (await this.coinbase() !== signerAddress)
                throw new Error(`Cannot sign messages for address 0x${signerAddress.toString(16).padStart(40, '0')}`);
            const messageToSign = this.mutateMessageForSigning(data);
            const signature = await this.signatureProvider(messageToSign);
            return this.encodeSignature(signature);
        };
        this.syncing = this.makeRequest(Rpc.Eth.Syncing.Request, Rpc.Eth.Syncing.Response);
        this.remoteProcedureCall = async (request) => {
            const requestBodyJson = JSON.stringify(request);
            const response = await this.fetch(this.jsonRpcEndpoint, { method: 'POST', body: requestBodyJson, headers: { 'Content-Type': 'application/json' } });
            if (!response.ok)
                throw new ErrorWithData(`${response.status}: ${response.statusText}\n${response.text()}`, request);
            const responseBody = await response.json();
            validateJsonRpcResponse(responseBody);
            if (isJsonRpcError(responseBody))
                throw new ErrorWithData(this.extractErrorMessage(responseBody.error), { request, code: responseBody.error.code, data: responseBody.error.data });
            return responseBody;
        };
        this.rlpEncodeTransaction = (transaction) => {
            const toEncode = [
                stripLeadingZeros(Bytes.fromUnsignedInteger(transaction.nonce, 256)),
                stripLeadingZeros(Bytes.fromUnsignedInteger(transaction.gasPrice, 256)),
                stripLeadingZeros(Bytes.fromUnsignedInteger(transaction.gasLimit, 256)),
                stripLeadingZeros(transaction.to !== null ? Bytes.fromUnsignedInteger(transaction.to, 256) : new Uint8Array(0)),
                stripLeadingZeros(Bytes.fromUnsignedInteger(transaction.value, 256)),
                new Uint8Array(transaction.data),
            ];
            if (!this.isSignedTransaction(transaction)) {
                toEncode.push(stripLeadingZeros(Bytes.fromUnsignedInteger(transaction.chainId, 256)));
                toEncode.push(stripLeadingZeros(new Uint8Array(0)));
                toEncode.push(stripLeadingZeros(new Uint8Array(0)));
            }
            else {
                toEncode.push(stripLeadingZeros(Bytes.fromUnsignedInteger(transaction.v, 256)));
                toEncode.push(stripLeadingZeros(Bytes.fromUnsignedInteger(transaction.r, 256)));
                toEncode.push(stripLeadingZeros(Bytes.fromUnsignedInteger(transaction.s, 256)));
            }
            return Bytes.fromByteArray(rlpEncode(toEncode));
        };
        this.isSignedTransaction = (transaction) => transaction.r !== undefined;
        this.mutateMessageForSigning = (message) => {
            message = (typeof message === 'string') ? new TextEncoder().encode(message) : message;
            const messagePrefix = new TextEncoder().encode(`\x19Ethereum Signed Message:\n${message.length.toString(10)}`);
            return Bytes.fromByteArray([...messagePrefix, ...message]);
        };
        this.encodeSignature = (signature) => {
            const v = (signature.yParity === 'even' ? 0n : 1n) + 27n;
            const rSegment = Bytes.fromUnsignedInteger(signature.r, 256);
            const sSegment = Bytes.fromUnsignedInteger(signature.s, 256);
            const vSegment = Bytes.fromUnsignedInteger(v, 8);
            return Bytes.fromByteArray([...rSegment, ...sSegment, ...vSegment]);
        };
        this.extractErrorMessage = (error) => {
            if (typeof error.data !== 'string')
                return error.message;
            // handle contract revert errors from Parity
            if (error.data.startsWith('Reverted 0x08c379a0')) {
                const offset = Number.parseInt(error.data.substr('Reverted 0x08c379a0'.length, 64), 16) * 2;
                const length = Number.parseInt(error.data.substr('Reverted 0x08c379a0'.length + offset, 64), 16) * 2;
                const message = new TextDecoder().decode(Bytes.fromHexString(error.data.substr(19 + offset + 64, length)));
                return `Contract Error: ${message}`;
            }
            // handle contract revert errors from Nethermind
            if (error.data.startsWith('revert: ')) {
                const message = error.data.substr('revert: '.length);
                return `Contract Error: ${message}`;
            }
            return error.message;
        };
        this.gasPriceInAttoethProvider = options.gasPriceInAttoethProvider;
        this.gasLimitProvider = options.gasLimitProvider || (async (transaction, estimator) => await estimator(transaction));
        this.addressProvider = options.addressProvider;
        this.signatureProvider = options.signatureProvider;
        this.chainId = (options.chainId !== undefined) ? Promise.resolve(options.chainId) : this.getChainId();
        this.coinbase = (this.addressProvider) ? this.addressProvider : this.makeRequest(Rpc.Eth.Coinbase.Request, Rpc.Eth.Coinbase.Response);
        // necessary to capture value for async call, since readonly modifier doesn't take effect until after constructor
        const getSignerAddress = this.addressProvider;
        this.getAccounts = (getSignerAddress !== undefined) ? async () => [await getSignerAddress()] : this.makeRequest(Rpc.Eth.Accounts.Request, Rpc.Eth.Accounts.Response);
        this.getGasPrice = (this.gasPriceInAttoethProvider) ? this.gasPriceInAttoethProvider : this.makeRequest(Rpc.Eth.GasPrice.Request, Rpc.Eth.GasPrice.Response);
        // silence NodeJS/Chrome warnings about unhandled rejections when we pre-fetch
        this.chainId.catch(() => { });
    }
}
//# sourceMappingURL=index.js.map