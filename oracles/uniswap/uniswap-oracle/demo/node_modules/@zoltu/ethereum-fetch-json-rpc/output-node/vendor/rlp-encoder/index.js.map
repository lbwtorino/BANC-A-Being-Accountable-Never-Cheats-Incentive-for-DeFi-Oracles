{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../source/vendor/rlp-encoder/index.ts"],"names":[],"mappings":"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","sourcesContent":["export type RlpItem = Uint8Array | RlpItemArray\nexport interface RlpItemArray extends Array<RlpItem> {}\n\nexport function rlpEncode(item: RlpItem): Uint8Array {\n\tif (item instanceof Uint8Array) {\n\t\treturn rlpEncodeItem(item)\n\t} else if (Array.isArray(item)) {\n\t\treturn rlpEncodeList(item)\n\t} else {\n\t\tthrow new Error(`Can only RLP encode Uint8Arrays (items) and arrays (lists).  Please encode your item into a Uint8Array first.\\nType: ${typeof item}\\n${item}`)\n\t}\n}\n\nfunction rlpEncodeItem(data: Uint8Array): Uint8Array {\n\tif (data.length === 1 && data[0] < 0x80) return rlpEncodeTiny(data)\n\telse if (data.length <= 55) return rlpEncodeSmall(data)\n\telse return rlpEncodeLarge(data)\n}\n\nfunction rlpEncodeList(items: Array<RlpItem>): Uint8Array {\n\tconst encodedItems = items.map(rlpEncode)\n\tconst encodedItemsLength = encodedItems.reduce((total, item) => total + item.length, 0)\n\tif (encodedItemsLength <= 55) {\n\t\tconst result = new Uint8Array(encodedItemsLength + 1)\n\t\tresult[0] = 0xc0 + encodedItemsLength\n\t\tlet offset = 1\n\t\tfor (let encodedItem of encodedItems) {\n\t\t\tresult.set(encodedItem, offset)\n\t\t\toffset += encodedItem.length\n\t\t}\n\t\treturn result\n\t} else {\n\t\tconst lengthBytes = hexStringToUint8Array(encodedItemsLength.toString(16))\n\t\tconst result = new Uint8Array(1 + lengthBytes.length + encodedItemsLength)\n\t\tresult[0] = 0xf7 + lengthBytes.length\n\t\tresult.set(lengthBytes, 1)\n\t\tlet offset = 1 + lengthBytes.length\n\t\tfor (let encodedItem of encodedItems) {\n\t\t\tresult.set(encodedItem, offset)\n\t\t\toffset += encodedItem.length\n\t\t}\n\t\treturn result\n\t}\n}\n\nfunction rlpEncodeTiny(data: Uint8Array): Uint8Array {\n\tif (data.length > 1) throw new Error(`rlpEncodeTiny can only encode single byte values.`)\n\tif (data[0] > 0x80) throw new Error(`rlpEncodeTiny can only encode values less than 0x80`)\n\treturn data\n}\n\nfunction rlpEncodeSmall(data: Uint8Array): Uint8Array {\n\tif (data.length === 1 && data[0] < 0x80) throw new Error(`rlpEncodeSmall can only encode data that is longer than 1 byte or has a value >= 0x7f`)\n\tif (data.length > 55) throw new Error(`rlpEncodeSmall can only encode data that is <= 55 bytes long`)\n\tconst result = new Uint8Array(data.length + 1)\n\tresult[0] = 0x80 + data.length\n\tresult.set(data, 1)\n\treturn result\n}\n\nfunction rlpEncodeLarge(data: Uint8Array): Uint8Array {\n\tif (data.length <= 55) throw new Error(`rlpEncodeLarge can only encode data that is > 55 bytes long`)\n\tconst lengthBytes = hexStringToUint8Array(data.length.toString(16))\n\tconst result = new Uint8Array(data.length + lengthBytes.length + 1)\n\tresult[0] = 0xb7 + lengthBytes.length\n\tresult.set(lengthBytes, 1)\n\tresult.set(data, 1 + lengthBytes.length)\n\treturn result\n}\n\nfunction hexStringToUint8Array(hex: string): Uint8Array {\n\tconst match = new RegExp(`^(?:0x)?([a-fA-F0-9]*)$`).exec(hex)\n\tif (match === null) throw new Error(`Expected a hex string encoded byte array with an optional '0x' prefix but received ${hex}`)\n\tconst maybeLeadingZero = (match[1].length % 2) ? '0' : ''\n\tconst normalized = `${maybeLeadingZero}${match[1]}`\n\tconst byteLength = normalized.length / 2\n\tconst bytes = new Uint8Array(byteLength)\n\tfor (let i = 0; i < byteLength; ++i) {\n\t\tbytes[i] = (Number.parseInt(`${normalized[i*2]}${normalized[i*2+1]}`, 16))\n\t}\n\treturn bytes\n}\n"]}