import { Bytes, TransactionReceipt, IUnsignedTransaction, IOffChainTransaction, Rpc, IJsonRpcRequest, IJsonRpcSuccess, JsonRpcMethod, IOnChainTransaction, ISignedTransaction, JsonRpc } from '@zoltu/ethereum-types';
import { ErrorWithData } from './error-with-data';
export { ErrorWithData };
declare type FetchResult = {
    readonly ok: boolean;
    readonly status: number;
    readonly statusText: string;
    json: () => Promise<any>;
    text: () => Promise<string>;
};
declare type FetchOptions = {
    method: string;
    body: string;
    headers: Record<string, string>;
};
declare type Fetch = (url: string, options: FetchOptions) => Promise<FetchResult>;
declare type SignatureLike = {
    r: bigint;
    s: bigint;
    yParity: 'even' | 'odd';
};
export interface FetchJsonRpcOptions {
    gasPriceInAttoethProvider?: FetchJsonRpc['gasPriceInAttoethProvider'];
    gasLimitProvider?: FetchJsonRpc['gasLimitProvider'];
    addressProvider?: FetchJsonRpc['addressProvider'];
    signatureProvider?: FetchJsonRpc['signatureProvider'];
    chainId?: bigint;
}
export declare class FetchJsonRpc implements JsonRpc {
    readonly jsonRpcEndpoint: string;
    readonly fetch: Fetch;
    readonly gasPriceInAttoethProvider?: () => Promise<bigint>;
    readonly gasLimitProvider: (transaction: IOffChainTransaction, estimator: (transaction: IOffChainTransaction) => Promise<bigint>) => Promise<bigint>;
    readonly addressProvider?: () => Promise<bigint>;
    readonly signatureProvider?: (bytes: Bytes) => Promise<SignatureLike>;
    private readonly chainId;
    constructor(jsonRpcEndpoint: string, fetch: Fetch, options: FetchJsonRpcOptions);
    readonly sendEth: (destination: bigint, amount: bigint) => Promise<TransactionReceipt>;
    readonly deployContract: (bytecode: Uint8Array, value?: bigint | undefined) => Promise<bigint>;
    readonly onChainContractCall: (transaction: PartiallyRequired<IOnChainTransaction, "to" | "data">) => Promise<TransactionReceipt>;
    readonly offChainContractCall: (transaction: PartiallyRequired<IOffChainTransaction, "to" | "data">) => Promise<Bytes>;
    private readonly executeTransaction;
    private readonly submitTransaction;
    private readonly makeRequest;
    readonly call: (transaction: IOffChainTransaction, blockTag?: bigint | "latest" | "earliest" | "pending" | undefined) => Promise<Bytes>;
    readonly coinbase: () => Promise<bigint | null>;
    readonly estimateGas: (transaction: IOffChainTransaction) => Promise<bigint>;
    readonly getAccounts: () => Promise<Array<bigint>>;
    readonly getBalance: (address: bigint, blockTag?: bigint | "latest" | "earliest" | "pending" | undefined) => Promise<bigint>;
    readonly getBlockByHash: (hash: bigint, fullTransactions?: boolean | undefined) => Promise<import("@zoltu/ethereum-types").Block | null>;
    readonly getBlockByNumber: (fullTransactions?: boolean | undefined, blockTag?: bigint | "latest" | "earliest" | "pending" | undefined) => Promise<import("@zoltu/ethereum-types").Block | null>;
    readonly getBlockNumber: () => Promise<bigint>;
    readonly getBlockTransactionCountByHash: (blockHash: bigint) => Promise<bigint>;
    readonly getBlockTransactionCountByNumber: (blockTag?: bigint | "latest" | "earliest" | "pending" | undefined) => Promise<bigint>;
    readonly getGasPrice: () => Promise<bigint>;
    readonly getChainId: () => Promise<bigint>;
    readonly getCode: (address: bigint, blockTag?: bigint | "latest" | "earliest" | "pending" | undefined) => Promise<Bytes>;
    readonly getLogs: (criteria: Rpc.Eth.GetLogs.Criteria) => Promise<import("@zoltu/ethereum-types").Log[]>;
    readonly getProof: (address: bigint, storageKeys: readonly bigint[], blockTag?: bigint | "latest" | "earliest" | "pending" | undefined) => Promise<import("@zoltu/ethereum-types").MerklePatritiaProof>;
    readonly getStorageAt: (address: bigint, index: bigint, blockTag?: bigint | "latest" | "earliest" | "pending" | undefined) => Promise<bigint>;
    readonly getTransactionByBlockHashAndIndex: (blockHash: bigint, transactionIndex: bigint) => Promise<import("@zoltu/ethereum-types").Transaction | null>;
    readonly getTransactionByBlockNumberAndIndex: (transactionIndex: bigint, blockTag?: bigint | "latest" | "earliest" | "pending" | undefined) => Promise<import("@zoltu/ethereum-types").Transaction | null>;
    readonly getTransactionByHash: (transactionHash: bigint) => Promise<import("@zoltu/ethereum-types").Transaction | null>;
    readonly getTransactionCount: (address: bigint, blockTag?: bigint | "latest" | "earliest" | "pending" | undefined) => Promise<bigint>;
    readonly getTransactionReceipt: (transactionHash: bigint) => Promise<TransactionReceipt | null>;
    readonly getUncleByBlockHashAndIndex: (blockHash: bigint, uncleIndex: bigint) => Promise<import("@zoltu/ethereum-types").Block | null>;
    readonly getUncleByBlockNumberAndIndex: (blockTag: import("@zoltu/ethereum-types").BlockTag, uncleIndex: bigint) => Promise<import("@zoltu/ethereum-types").Block | null>;
    readonly getUncleCountByBlockHash: (blockHash: bigint) => Promise<bigint>;
    readonly getUncleCountByBlockNumber: (blockTag: import("@zoltu/ethereum-types").BlockTag) => Promise<bigint>;
    readonly getProtocolVersion: () => Promise<string>;
    readonly sendRawTransaction: (signedTransaction: Uint8Array) => Promise<bigint>;
    readonly sendTransaction: (transaction: Partial<IUnsignedTransaction> & {
        to: bigint | null;
    }) => Promise<bigint>;
    readonly signTransaction: (transaction: Partial<IUnsignedTransaction> & {
        to: bigint | null;
    }) => Promise<{
        decodedTransaction: ISignedTransaction;
        encodedTransaction: Uint8Array;
    }>;
    readonly sign: (signerAddress: bigint, data: Uint8Array) => Promise<Bytes>;
    readonly syncing: () => Promise<false | {
        readonly currentBlock: bigint;
        readonly highestBlock: bigint;
        readonly startingBlock: bigint;
    }>;
    readonly remoteProcedureCall: <TRawRequest extends IJsonRpcRequest<JsonRpcMethod, any[]>, TRawResponse extends IJsonRpcSuccess<any>>(request: TRawRequest) => Promise<TRawResponse>;
    private readonly rlpEncodeTransaction;
    private readonly isSignedTransaction;
    private readonly mutateMessageForSigning;
    private readonly encodeSignature;
    private readonly extractErrorMessage;
}
declare type PartiallyRequired<T, K extends keyof T> = {
    [Key in Exclude<keyof T, K>]?: T[Key];
} & {
    [Key in K]-?: T[Key];
};
