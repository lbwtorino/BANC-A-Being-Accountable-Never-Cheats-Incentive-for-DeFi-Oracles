{"version":3,"file":"ethereum.js","sourceRoot":"","sources":["../source/ethereum.ts"],"names":[],"mappings":"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","sourcesContent":["import * as secp256k1 from './secp256k1'\nimport * as keccak256 from './keccak256'\n\n/**\n * Derives an Ethereum address from a secp256k1 public key point.\n *\n * @param publicKey A secp256k1 public key point.\n * @returns An Ethereum address, as a 20-byte Uint8Array.\n */\nexport async function publicKeyToAddress(publicKey: secp256k1.AffinePoint): Promise<bigint> {\n\tconst encodedPublicKey = secp256k1.encodePoint(publicKey)\n\tconst hashedPublicKey = await keccak256.hash(encodedPublicKey.subarray(1, 65))\n\treturn hashedPublicKey & 0xffffffffffffffffffffffffffffffffffffffffn\n}\n\n/**\n * Turns an Ethereum address into a string, including lower/upper case for checksum information encoding.\n * @param address An Ethereum address as a bigint.\n * @returns An Ethereum address as a checksummed string.\n */\nexport async function addressToChecksummedString(address: bigint): Promise<string> {\n\tconst addresString = address.toString(16).padStart(40, '0')\n\tconst addressHash = await keccak256.hash(new TextEncoder().encode(addresString))\n\tlet result = ''\n\tfor (let i = 0; i < addresString.length; ++i) {\n\t\tconst character = addresString[i]\n\t\tconst isLetter = /[a-fA-F]/.test(character)\n\t\tconst checksumBit = addressHash & (2n**(255n - 4n * BigInt(i)))\n\t\tif (isLetter && checksumBit) result += character.toUpperCase()\n\t\telse result += character.toLowerCase()\n\t}\n\treturn result\n}\n\n/**\n * Validates that a hex string address is valid per checksum check.\n * @param addressString Address as a hex string, with checksum casing encoded in it.\n * @returns True if the address is valid, false otherwise.\n */\nexport async function validateAddressChecksum(addressString: string): Promise<boolean> {\n\taddressString = addressString.startsWith('0x') ? addressString : `0x${addressString}`\n\tif (!/0x[a-fA-F0-9]{40}/.test(addressString)) return false\n\tconst addressBigint = BigInt(addressString)\n\tconst checksummedAddress = await addressToChecksummedString(addressBigint)\n\treturn (checksummedAddress === addressString.slice(2))\n}\n\n/**\n * Signs the keccak256 hash of `message` using `privateKey`.\n * @param privateKey The private key used to sign `message` with.\n * @param message The message to be signed.  This can be either a string, which will be UTF-8 encoded, or a byte array.\n * @returns The signature of `message` signed by `privateKey`.\n */\nexport async function signRaw(privateKey: bigint, message: string | Uint8Array): Promise<secp256k1.Signature> {\n\tmessage = (typeof message === 'string') ? new TextEncoder().encode(message) : message\n\tconst hashedMessage = await keccak256.hash(message)\n\tconst signature = await secp256k1.sign(privateKey, hashedMessage)\n\treturn signature\n}\n\n/**\n * Many signing tools in the Ethereum ecosystem prefix all signed messages with a magic string before signing.  This applies that prefix and returns the message that most tools will _actually_ sign.  This can be passed to `signRaw` for actual signing.\n * @param message The message to prep for signing.  This can be either a string, which will be UTF-8 encoded, or a byte array.\n * @returns A message that can be signed by `signRaw` and will be correctly verified by various Ethereum ecosystem tools.\n */\nexport function mutateMessageForSigning(message: string | Uint8Array): Uint8Array {\n\tmessage = (typeof message === 'string') ? new TextEncoder().encode(message) : message\n\tconst messagePrefix = new TextEncoder().encode(`\\x19Ethereum Signed Message:\\n${message.length.toString(10)}`)\n\treturn new Uint8Array([...messagePrefix, ...message])\n}\n\n/**\n * Signs the keccak256 hash of a prefixed version of {message}.  Many signing tools in the Ethereum ecosystem prefix all signed messages with a magic prefix before signing.\n *\n * The magic prefix is `\\x19Ethereum Signed Message:\\n${messageLength}` where `messageLength` is the base-10 ASCII encoded length of the [UTF-8 encoded (if message is a string)] message\n * @param privateKey The private key used to sign `message` with.\n * @param message The message to be signed.  This can be either a string, which will be UTF-8 encoded, or a byte array.\n * @returns The signature of the mutated `message` signed by `privateKey`.\n */\nexport async function mutateAndSign(privateKey: bigint, message: string | Uint8Array): Promise<secp256k1.Signature> {\n\tconst bytesToSign = mutateMessageForSigning(message)\n\treturn signRaw(privateKey, bytesToSign)\n}\n\n/**\n * Converts a Solidity canonical function signature (e.g., `transfer(address,uint256)`) into its function selector.  See https://solidity.readthedocs.io/en/latest/abi-spec.html#function-selector for details.\n * @param functionSignature The canonical expression of the Solidity function signature.  See https://solidity.readthedocs.io/en/latest/abi-spec.html#function-selector for details on constructing this appropriately.\n */\nexport async function functionSignatureToSelector(functionSignature: string): Promise<number> {\n\tconst functionSignatureBytes = new TextEncoder().encode(functionSignature)\n\tconst hash = await keccak256.hash(functionSignatureBytes)\n\treturn Number(hash >> 224n)\n}\n"]}