export interface AffinePoint {
    /** [0, 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f) */
    x: bigint;
    /** [0, 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f) */
    y: bigint;
}
export interface JacobianPoint {
    /** [0, 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f) */
    x: bigint;
    /** [0, 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f) */
    y: bigint;
    /** [0, 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f) */
    z: bigint;
}
export interface Signature {
    /** [0, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141) */
    r: bigint;
    /** [0, 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0) */
    s: bigint;
    recoveryParameter: 0 | 1;
}
export declare const fieldModulus: 115792089237316195423570985008687907853269984665640564039457584007908834671663n;
export declare const basePoint: JacobianPoint;
export declare const basePointOrder: 115792089237316195423570985008687907852837564279074904382605163141518161494337n;
/**
 * Generates a random valid private key for usage is secp256k1 signing.
 */
export declare function generatePrivateKey(): Promise<bigint>;
/**
 * Derives the public key that corresponds to {privateKey}.
 * @param privateKey A valid secp256k1 private key.  Usually a random number. Must be in the range (0, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141).
 */
export declare function privateKeyToPublicKey(privateKey: bigint): Promise<JacobianPoint & AffinePoint>;
export declare function encodePoint(point: JacobianPoint | AffinePoint): Uint8Array & {
    length: 65;
};
export declare function encodePointCompressed(point: JacobianPoint | AffinePoint): Uint8Array & {
    length: 33;
};
export declare function decodePoint(encoded: ArrayLike<number> & {
    length: 65;
}): JacobianPoint & AffinePoint;
/**
 * Sign {messageHash} with {privateKey}.  {messageHash} is usually the output of a hashing function (e.g., keccak256) run against some data that you wish to sign.
 * @param privateKey The private key you wish to sign with.  Usually a randomly generated 256-bit number.  Note that the valid range of values is actually constrained to (0, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141)
 * @param messageHash The 256-bit number you wish to sign.  Usually this is the output of a hashing function like keccak256. [0, 2**256)
 */
export declare function sign(privateKey: bigint, messageHash: bigint): Promise<Signature>;
/**
 * Verify that {signature} is the result of signing {messageHash} with the private key corresponding to {publicKey}.
 * @param publicKey The secp256k1 public key cooresponding to the private key that signed messageHash.
 * @param messageHash The 256-bit number that was signed.  Usually this is the output of a hashing function like keccak256. [0, 2**256)
 * @param signature The signature output from signing with the private key cooresponding to {publicKey} parameter
 */
export declare function verify(publicKey: JacobianPoint | AffinePoint, messageHash: bigint, signature: Omit<Signature, 'recoveryParameter'>): Promise<boolean>;
/**
 * These are here for reference.  They are nearly the most simple implementation of secp256k1 point add/point multiply functions.  The only optimization they have is that they use double and add for multiplication rather than adding a number 2**256 times in a loop (which is impossible on modern computers).  While they code is not used since using Jacobian coordinates are about 30x faster, I'm leaving it in here for reference in case some future reader wants to understand what is happening under the hood a litle better.
 */
