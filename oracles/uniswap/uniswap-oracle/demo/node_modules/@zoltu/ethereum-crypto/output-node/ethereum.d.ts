import * as secp256k1 from './secp256k1';
/**
 * Derives an Ethereum address from a secp256k1 public key point.
 *
 * @param publicKey A secp256k1 public key point.
 * @returns An Ethereum address, as a 20-byte Uint8Array.
 */
export declare function publicKeyToAddress(publicKey: secp256k1.AffinePoint): Promise<bigint>;
/**
 * Turns an Ethereum address into a string, including lower/upper case for checksum information encoding.
 * @param address An Ethereum address as a bigint.
 * @returns An Ethereum address as a checksummed string.
 */
export declare function addressToChecksummedString(address: bigint): Promise<string>;
/**
 * Validates that a hex string address is valid per checksum check.
 * @param addressString Address as a hex string, with checksum casing encoded in it.
 * @returns True if the address is valid, false otherwise.
 */
export declare function validateAddressChecksum(addressString: string): Promise<boolean>;
/**
 * Signs the keccak256 hash of `message` using `privateKey`.
 * @param privateKey The private key used to sign `message` with.
 * @param message The message to be signed.  This can be either a string, which will be UTF-8 encoded, or a byte array.
 * @returns The signature of `message` signed by `privateKey`.
 */
export declare function signRaw(privateKey: bigint, message: string | Uint8Array): Promise<secp256k1.Signature>;
/**
 * Many signing tools in the Ethereum ecosystem prefix all signed messages with a magic string before signing.  This applies that prefix and returns the message that most tools will _actually_ sign.  This can be passed to `signRaw` for actual signing.
 * @param message The message to prep for signing.  This can be either a string, which will be UTF-8 encoded, or a byte array.
 * @returns A message that can be signed by `signRaw` and will be correctly verified by various Ethereum ecosystem tools.
 */
export declare function mutateMessageForSigning(message: string | Uint8Array): Uint8Array;
/**
 * Signs the keccak256 hash of a prefixed version of {message}.  Many signing tools in the Ethereum ecosystem prefix all signed messages with a magic prefix before signing.
 *
 * The magic prefix is `\x19Ethereum Signed Message:\n${messageLength}` where `messageLength` is the base-10 ASCII encoded length of the [UTF-8 encoded (if message is a string)] message
 * @param privateKey The private key used to sign `message` with.
 * @param message The message to be signed.  This can be either a string, which will be UTF-8 encoded, or a byte array.
 * @returns The signature of the mutated `message` signed by `privateKey`.
 */
export declare function mutateAndSign(privateKey: bigint, message: string | Uint8Array): Promise<secp256k1.Signature>;
/**
 * Converts a Solidity canonical function signature (e.g., `transfer(address,uint256)`) into its function selector.  See https://solidity.readthedocs.io/en/latest/abi-spec.html#function-selector for details.
 * @param functionSignature The canonical expression of the Solidity function signature.  See https://solidity.readthedocs.io/en/latest/abi-spec.html#function-selector for details on constructing this appropriately.
 */
export declare function functionSignatureToSelector(functionSignature: string): Promise<number>;
