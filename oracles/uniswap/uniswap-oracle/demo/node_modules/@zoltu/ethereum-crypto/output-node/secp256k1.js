"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utilities_1 = require("./utilities");
exports.fieldModulus = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn;
// const b = 7n
exports.basePoint = {
    x: 55066263022277343669578718895168534326250603453777594175500187360389116729240n,
    y: 32670510020758816978083085130507043184471273380659243275938904335757337482424n,
    z: 1n,
};
exports.basePointOrder = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n;
// const h = 1n
/**
 * Generates a random valid private key for usage is secp256k1 signing.
 */
async function generatePrivateKey() {
    let result = 2n ** 256n;
    while (result >= exports.basePointOrder || result <= 0) {
        result = utilities_1.bytesToBigint(crypto.getRandomValues(new Uint8Array(32)));
    }
    validatePrivateKey(result);
    return result;
}
exports.generatePrivateKey = generatePrivateKey;
/**
 * Derives the public key that corresponds to {privateKey}.
 * @param privateKey A valid secp256k1 private key.  Usually a random number. Must be in the range (0, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141).
 */
async function privateKeyToPublicKey(privateKey) {
    privateKey = (typeof privateKey === 'bigint') ? privateKey : utilities_1.bytesToBigint(privateKey);
    validatePrivateKey(privateKey);
    // we convert to affine and back to jacobian because that will result in getting a public key out that is compatible with both jacobian or affine systems, while the original jacobian key may only be compatible with jacobian processing
    const jacobianPublicKey = pointMultiply(exports.basePoint, privateKey);
    const affinePublicKey = jacobianToAffine(jacobianPublicKey);
    return affineToJacobian(affinePublicKey);
}
exports.privateKeyToPublicKey = privateKeyToPublicKey;
function encodePoint(point) {
    const affinePoint = ('z' in point) ? jacobianToAffine(point) : point;
    const result = [4];
    for (let i = 0n; i < 32n; ++i) {
        result.push(Number((affinePoint.x >> 248n - 8n * i) & 0xffn));
    }
    for (let i = 0n; i < 32n; ++i) {
        result.push(Number((affinePoint.y >> 248n - 8n * i) & 0xffn));
    }
    return new Uint8Array(result);
}
exports.encodePoint = encodePoint;
function encodePointCompressed(point) {
    const affinePoint = ('z' in point) ? jacobianToAffine(point) : point;
    return new Uint8Array([(affinePoint.y % 2n) ? 0x03 : 0x02, ...utilities_1.bigintToBytes(affinePoint.x, 32)]);
}
exports.encodePointCompressed = encodePointCompressed;
function decodePoint(encoded) {
    if (encoded[0] !== 4)
        throw new Error(`This is not an encoded point.  Perhaps you have a compressed point?\n${encoded}`);
    let x = 0n;
    for (let i = 1; i <= 32; ++i) {
        const shift = ((32n - BigInt(i)) * 8n);
        x |= BigInt(encoded[i]) << shift;
    }
    let y = 0n;
    for (let i = 1; i <= 32; ++i) {
        const shift = ((32n - BigInt(i)) * 8n);
        y |= BigInt(encoded[i + 32]) << shift;
    }
    return affineToJacobian({ x, y });
}
exports.decodePoint = decodePoint;
/**
 * Sign {messageHash} with {privateKey}.  {messageHash} is usually the output of a hashing function (e.g., keccak256) run against some data that you wish to sign.
 * @param privateKey The private key you wish to sign with.  Usually a randomly generated 256-bit number.  Note that the valid range of values is actually constrained to (0, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141)
 * @param messageHash The 256-bit number you wish to sign.  Usually this is the output of a hashing function like keccak256. [0, 2**256)
 */
async function sign(privateKey, messageHash) {
    validateMessageHash(messageHash);
    validatePrivateKey(privateKey);
    let r = 0n;
    let s = 0n;
    let recoveryParameter = 0;
    let nonce = 0n;
    while (r === 0n || s === 0n) {
        nonce = await generateDeterministicSigningNonce(privateKey, messageHash);
        const point = jacobianToAffine(pointMultiply(exports.basePoint, nonce));
        // ethereum specific case, in bitcoin `r = point.x % basePointOrder` and point.x being larger than basePointOrder is encoded as part of the `recoveryParameter`.
        if (point.x >= exports.basePointOrder)
            continue;
        r = point.x;
        s = utilities_1.modularMultiplicitiveInverse(nonce, exports.basePointOrder) * (messageHash + r * privateKey) % exports.basePointOrder;
        let yIsOdd = !!(point.y % 2n);
        // if there are multiple valid values of s, prefer the smaller one
        if (s >= exports.basePointOrder / 2n) {
            s = exports.basePointOrder - s;
            yIsOdd = !yIsOdd; // not sure why this is necessary, but it is...
        }
        recoveryParameter = Number(yIsOdd);
    }
    return { r, s, recoveryParameter };
}
exports.sign = sign;
/**
 * Verify that {signature} is the result of signing {messageHash} with the private key corresponding to {publicKey}.
 * @param publicKey The secp256k1 public key cooresponding to the private key that signed messageHash.
 * @param messageHash The 256-bit number that was signed.  Usually this is the output of a hashing function like keccak256. [0, 2**256)
 * @param signature The signature output from signing with the private key cooresponding to {publicKey} parameter
 */
async function verify(publicKey, messageHash, signature) {
    validateMessageHash(messageHash);
    const affinePublicKey = ('z' in publicKey) ? jacobianToAffine(publicKey) : publicKey;
    const jacobianPublicKey = ('z' in publicKey) ? publicKey : affineToJacobian(publicKey);
    // verify it isn't the point at infinity
    if (isAtInfinity(jacobianPublicKey))
        return false;
    // verify the point is on the curve y^2 = x^3 + 7 (the secp256k1 curve)
    if ((affinePublicKey.x ** 3n + 7n) % exports.fieldModulus !== (affinePublicKey.y ** 2n) % exports.fieldModulus)
        return false;
    // verify that the base point order times the point is the point at infinity
    const expectedInfinitePoint = pointMultiply(jacobianPublicKey, exports.basePointOrder);
    if (!isAtInfinity(expectedInfinitePoint))
        return false;
    // verify r is in the proper range
    const signatureR = signature.r;
    if (signatureR <= 0)
        return false;
    if (signatureR >= exports.basePointOrder)
        return false;
    // verify s is in the proper range
    const signatureS = signature.s;
    if (signatureS <= 0)
        return false;
    if (signatureS >= exports.basePointOrder)
        return false;
    // verify the signature
    const inverseS = utilities_1.modularMultiplicitiveInverse(signatureS, exports.basePointOrder);
    const u1 = messageHash * inverseS % exports.basePointOrder;
    const u2 = signatureR * inverseS % exports.basePointOrder;
    const calculatedPoint = pointAdd(pointMultiply(exports.basePoint, u1), pointMultiply(jacobianPublicKey, u2));
    if (isAtInfinity(calculatedPoint))
        return false;
    if (jacobianToAffine(calculatedPoint).x !== signatureR)
        return false;
    // all of the checks for validity passed, thus the signature is valid
    return true;
}
exports.verify = verify;
async function generateDeterministicSigningNonce(privateKey, messageHash) {
    const privateKeyBytes = utilities_1.bigintToBytes(privateKey, 32);
    const messageHashBytes = utilities_1.bigintToBytes(messageHash, 32);
    let v = new Uint8Array(32).fill(1);
    let k = new Uint8Array(32).fill(0);
    k = await hmac(k, [...v, 0, ...privateKeyBytes, ...messageHashBytes]);
    v = await hmac(k, v);
    k = await hmac(k, [...v, 1, ...privateKeyBytes, ...messageHashBytes]);
    v = await hmac(k, v);
    while (true) {
        v = await hmac(k, v);
        const nonce = utilities_1.bytesToBigint(v);
        if (nonce >= 1n && nonce < exports.basePointOrder)
            return nonce;
        k = await hmac(k, [...v, 0]);
        v = await hmac(k, v);
    }
}
async function hmac(key, data) {
    const cryptoKey = await crypto.subtle.importKey('raw', key, { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']);
    const signature = await crypto.subtle.sign('HMAC', cryptoKey, new Uint8Array(data));
    return new Uint8Array(signature);
}
function validatePrivateKey(privateKey) {
    if (privateKey < 1)
        throw new Error(`Illegal private key.  Must be in range [1, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364140]`);
    if (privateKey >= exports.basePointOrder)
        throw new Error(`Illegal private key.  Must be in range [1, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141)`);
}
function validateMessageHash(messageHash) {
    if (messageHash < 0)
        throw new Error(`Message hash must be a positive number.`);
    if (messageHash >= 2n ** 256n)
        throw new Error(`Message hash is too big.  It must be a 256-bit number.`);
}
function pointMultiply(point, scalar) {
    // https://en.wikipedia.org/wiki/Exponentiation_by_squaring (aka: double-and-add)
    let result = { x: 1n, y: 1n, z: 0n };
    for (let i = 0n; i < 256n; ++i) {
        result = pointDouble(result);
        const bit = !!((scalar >> 255n - i) & 1n);
        if (bit)
            result = pointAdd(result, point);
    }
    return normalizePointInField(result);
}
function pointAdd(first, second) {
    // http://www.hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#addition-add-2007-bl
    if (isAtInfinity(first))
        return second;
    if (isAtInfinity(second))
        return first;
    const firstZSquared = first.z * first.z % exports.fieldModulus;
    const secondZSquared = second.z * second.z % exports.fieldModulus;
    const u1 = first.x * secondZSquared % exports.fieldModulus;
    const u2 = second.x * firstZSquared % exports.fieldModulus;
    const s1 = first.y * second.z * secondZSquared % exports.fieldModulus;
    const s2 = second.y * first.z * firstZSquared % exports.fieldModulus;
    if (u1 === u2) {
        if (s1 === s2)
            return pointDouble(first);
        else
            return { x: 1n, y: 1n, z: 0n };
    }
    const h = (u2 - u1) % exports.fieldModulus;
    const i = (2n * h) ** 2n % exports.fieldModulus;
    const j = h * i % exports.fieldModulus;
    const r = 2n * (s2 - s1) % exports.fieldModulus;
    const v = u1 * i % exports.fieldModulus;
    const x = (r * r - j - 2n * v) % exports.fieldModulus;
    const y = (r * (v - x) - 2n * s1 * j) % exports.fieldModulus;
    const z = ((first.z + second.z) ** 2n - firstZSquared - secondZSquared) * h % exports.fieldModulus;
    return { x, y, z };
}
function pointDouble(point) {
    const xSquared = point.x * point.x % exports.fieldModulus;
    const ySquared = point.y * point.y % exports.fieldModulus;
    const yQuarted = ySquared * ySquared % exports.fieldModulus;
    const d = 2n * ((point.x + ySquared) ** 2n - xSquared - yQuarted) % exports.fieldModulus;
    const e = 3n * xSquared % exports.fieldModulus;
    const f = e ** 2n % exports.fieldModulus;
    const x = (f - 2n * d) % exports.fieldModulus;
    const y = (e * (d - x) - 8n * yQuarted) % exports.fieldModulus;
    const z = 2n * point.y * point.z % exports.fieldModulus;
    return { x, y, z };
}
function isAtInfinity(point) {
    if ('z' in point) {
        if (point.z !== 0n)
            return false;
        if (point.x ** 3n % exports.fieldModulus !== point.y ** 2n % exports.fieldModulus)
            return false;
        return true;
    }
    else {
        if (point.x !== 0n)
            return false;
        if (point.y !== 0n)
            return false;
        return true;
    }
}
function affineToJacobian(affine) {
    if (isAtInfinity(affine))
        return { x: 1n, y: 1n, z: 0n };
    return {
        x: affine.x,
        y: affine.y,
        z: 1n
    };
}
function jacobianToAffine(jacobian) {
    if (isAtInfinity(jacobian))
        return { x: 0n, y: 0n };
    if (jacobian.z === 1n)
        return { x: jacobian.x, y: jacobian.y };
    const zInverse = utilities_1.modularMultiplicitiveInverse(jacobian.z, exports.fieldModulus);
    return {
        x: jacobian.x * zInverse ** 2n % exports.fieldModulus,
        y: jacobian.y * zInverse ** 3n % exports.fieldModulus,
    };
}
function normalizePointInField(point) {
    const x = normalizeScalarInField(point.x);
    const y = normalizeScalarInField(point.y);
    if ('z' in point) {
        const z = normalizeScalarInField(point.z);
        return { x, y, z };
    }
    else {
        return { x, y };
    }
}
function normalizeScalarInField(value) {
    if (value >= exports.fieldModulus)
        return value % exports.fieldModulus;
    if (value < 0n)
        return normalizeScalarInField(value + exports.fieldModulus);
    return value;
}
/**
 * These are here for reference.  They are nearly the most simple implementation of secp256k1 point add/point multiply functions.  The only optimization they have is that they use double and add for multiplication rather than adding a number 2**256 times in a loop (which is impossible on modern computers).  While they code is not used since using Jacobian coordinates are about 30x faster, I'm leaving it in here for reference in case some future reader wants to understand what is happening under the hood a litle better.
 */
// function pointAdd(first: AffinePoint, second: AffinePoint): AffinePoint {
// 	// if one of the points is the infinite point, then return the other
// 	if (first.x === 0n && first.y === 0n) return second
// 	if (second.x === 0n && second.y === 0n) return first
// 	// if both points are the same, we can use the doubling formula (adding a point to itself doesn't work)
// 	if (first.x === second.x && first.y === second.y) return pointDouble(first)
// 	// if one point is the negation of the other, then return the infinite point
// 	if (first.x === second.x && first.y === first.y * -1n + fieldModulus) return { x:0n, y:0n }
// 	// if x is the same but y is different then it means we are adding a point to its negation, in which case the result is the point at infinity
// 	if (first.x === second.x) return {x:0n, y:0n}
// 	const slope = div(sub(second.y, first.y), sub(second.x, first.x))
// 	const resultX = sub(sub(slope * slope, first.x), second.x)
// 	const resultY = sub(slope * sub(first.x, resultX), first.y)
// 	return { x: resultX % fieldModulus, y: resultY % fieldModulus }
// }
// function pointDouble(point: AffinePoint): AffinePoint {
// 	if (point.x === 0n && point.y === 0n) return point
// 	if (point.y + point.y === 0n) return {x:0n, y:0n}
// 	const slope = div(3n * point.x * point.x, 2n * point.y)
// 	const resultX = sub(sub(slope * slope, point.x), point.x)
// 	const resultY = sub(slope * sub(point.x, resultX), point.y)
// 	return { x: resultX % fieldModulus, y: resultY % fieldModulus }
// }
// function sub(minuend: bigint, subtrahend: bigint): bigint {
// 	return modularSubtract(minuend, subtrahend, fieldModulus)
// }
// function div(dividend: bigint, divisor: bigint): bigint {
// 	return modularDivide(dividend, divisor, fieldModulus)
// }
//# sourceMappingURL=secp256k1.js.map