export function validateByteArray(message) {
    for (const maybeByte of message) {
        if (maybeByte >= 2 ** 8)
            throw new Error(`Expected a byte array but received an array with elements larger than 2**8`);
        if (maybeByte < 0)
            throw new Error(`Expected byte array but received an array with negative elements`);
    }
}
export function chunkArray(array, chunkSize) {
    const chunks = new Array();
    for (let i = 0; i < array.length; i += chunkSize) {
        const chunk = array.slice(i, i + chunkSize);
        chunks.push(chunk);
    }
    return chunks;
}
export function bytesToBigint(array) {
    let result = 0n;
    for (let i = 0; i < array.length; ++i) {
        const shiftAmount = BigInt((array.length - 1 - i) * 8);
        const byte = BigInt(array[i]);
        result |= byte << shiftAmount;
    }
    return result;
}
export function bigintToBytes(value, numberOfBytes) {
    if (value >= 2n ** BigInt(numberOfBytes * 8))
        throw new Error(`Cannot encode ${value} in ${numberOfBytes} bytes.`);
    if (value < 0)
        throw new Error(`This function cannot encode a negative number (${value}).`);
    const result = new Uint8Array(numberOfBytes);
    for (let i = 0; i < numberOfBytes; ++i) {
        const shiftAmount = BigInt((numberOfBytes - 1 - i) * 8);
        const byte = Number((value >> shiftAmount) & 0xffn);
        result[i] = byte;
    }
    return result;
}
export function rightCircularShift64(value, bits) {
    value = value % 2n ** 64n;
    bits = bits % 64n;
    const newSignificantBits = (value << (64n - bits)) % 2n ** 64n;
    const newInsignificantBits = value >> bits;
    return newSignificantBits | newInsignificantBits;
}
export function leftCircularShift64(value, bits) {
    value = value % 2n ** 64n;
    bits = bits % 64n;
    const newSignificantBits = (value << bits) % 2n ** 64n;
    const newInsignificantBits = value >> (64n - bits);
    return newSignificantBits | newInsignificantBits;
}
export function modularSubtract(minuend, subtrahend, fieldModulus) {
    const difference = (minuend - subtrahend) % fieldModulus;
    return (difference >= 0) ? difference : difference + fieldModulus;
}
export function modularDivide(dividend, divisor, fieldModulus) {
    return dividend * modularMultiplicitiveInverse(divisor, fieldModulus) % fieldModulus;
}
export function modularMultiplicitiveInverse(base, fieldModulus) {
    let power = fieldModulus - 2n;
    let result = 1n;
    while (power > 0n) {
        if (power % 2n) {
            result *= base;
            result %= fieldModulus;
        }
        power /= 2n;
        base *= base;
        base %= fieldModulus;
    }
    return result;
}
export function getFirstBits(data, numberOfBits) {
    if (numberOfBits > 32)
        throw new Error(`Can only strip off up to the first 32 bits.`);
    const result = new Array();
    for (let i = 0; i < numberOfBits; ++i) {
        result.push(getBit(data[Math.floor(i / 8)], i % 8));
    }
    return result;
}
export function toBitArray(data) {
    const result = new Array();
    for (let byte of data) {
        for (let i = 0; i < 8; ++i) {
            result.push(getBit(byte, i));
        }
    }
    return result;
}
export function getBit(data, offset) {
    if (data >= 2 ** 8)
        throw new Error(`Only supports 8-bit numbers`);
    return !!((data >>> (8 - offset - 1)) & 0b1);
}
export function bitArrayToNumber(data) {
    let result = 0;
    for (let i = 0; i < data.length; ++i) {
        result = result ^ Number(data[i]) << (data.length - i - 1);
    }
    return result;
}
//# sourceMappingURL=utilities.js.map