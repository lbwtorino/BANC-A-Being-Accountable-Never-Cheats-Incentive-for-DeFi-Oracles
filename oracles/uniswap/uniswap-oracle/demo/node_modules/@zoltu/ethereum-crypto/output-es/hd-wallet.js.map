{"version":3,"file":"hd-wallet.js","sourceRoot":"","sources":["../source/hd-wallet.ts"],"names":[],"mappings":"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","sourcesContent":["import { bigintToBytes, bytesToBigint } from './utilities';\nimport * as secp256k1 from './secp256k1';\n\nconst masterSeed = new TextEncoder().encode('Bitcoin seed')\n\n/**\n * @param seed The seed value to use, such as that returned by `mnemonic.toSeed()`. If a bigint is supplied, it is converted to a 64-byte array (big endian, left padded with 0)\n * @param derivationPath The BIP 32 derivation path to use when deriving the key from the seed.  If not supplied then `m/44'/60'/0'/0/0` is used.\n * @returns A 64-bit private key valid for usage in secp256k1.\n */\nexport async function privateKeyFromSeed(seed: Uint8Array | bigint, derivationPath?: string): Promise<bigint> {\n\tif (typeof seed === 'bigint') seed = bigintToBytes(seed, 64)\n\tif (derivationPath === undefined) derivationPath = `m/44'/60'/0'/0/0`\n\n\tconst hmacKey = await crypto.subtle.importKey('raw', masterSeed, {name:'HMAC', hash:'SHA-512'}, true, ['sign'])\n\tconst masterSeedHmac = new Uint8Array(await crypto.subtle.sign('HMAC', hmacKey, seed))\n\tconst masterKey = bytesToBigint(masterSeedHmac.subarray(0, 32))\n\tif (masterKey === 0n) throw new Error(`Invalid seed.`)\n\tif (masterKey >= secp256k1.basePointOrder) throw new Error(`Invalid seed.`)\n\tconst masterChainCode = masterSeedHmac.subarray(32, 64) as Uint8Array & {length:32}\n\tconst chain = decodeDerivationPath(derivationPath)\n\tlet currentKeyCodePair: KeyChainPair = { key: masterKey, chainCode: masterChainCode }\n\tfor (const link of chain) {\n\t\tcurrentKeyCodePair = await deriveChild(currentKeyCodePair, link.index, link.hardened)\n\t}\n\n\treturn currentKeyCodePair.key\n}\n\nasync function deriveChild(parent: KeyChainPair, index: number, hardened: boolean): Promise<KeyChainPair> {\n\tfunction hardenedHmacData(): Uint8Array {\n\t\tconst keyBytes = bigintToBytes(parent.key, 32)\n\t\treturn new Uint8Array([0x00, ...keyBytes, ...indexBytes])\n\t}\n\tasync function normalHmacData(): Promise<Uint8Array> {\n\t\tconst publicKey = await secp256k1.privateKeyToPublicKey(parent.key)\n\t\tconst compressedPublicKey = secp256k1.encodePointCompressed(publicKey)\n\t\treturn new Uint8Array([...compressedPublicKey, ...indexBytes])\n\t}\n\tconst indexBytes = bigintToBytes(BigInt(index + (hardened ? 2**31 : 0)), 4)\n\tconst hmacData = hardened ? hardenedHmacData() : await normalHmacData()\n\tconst hmacKey = await crypto.subtle.importKey('raw', parent.chainCode, {name:'HMAC', hash:'SHA-512', length: 256}, true, ['sign'])\n\tconst hmac = new Uint8Array(await crypto.subtle.sign('HMAC', hmacKey, hmacData))\n\tconst childKey = (bytesToBigint(hmac.subarray(0, 32)) + parent.key) % secp256k1.basePointOrder\n\tconst childChainCode = hmac.subarray(32, 64) as Uint8Array & {length:32}\n\tif (childKey === 0n) return await deriveChild(parent, index + 1, hardened)\n\tif (childKey >= secp256k1.basePointOrder) return await deriveChild(parent, index + 1, hardened)\n\n\treturn { key: childKey, chainCode: childChainCode }\n}\n\nfunction decodeDerivationPath(derivationPath: string): Array<{hardened:boolean,index:number}> {\n\tif (!/^m(?:\\/\\d+'?)*$/g.test(derivationPath)) throw new Error(`Invalid derivation path ${derivationPath}`);\n\n\tconst result: Array<{hardened:boolean,index:number}> = []\n\tconst regularExpression = /\\/(\\d+'?)/g\n\tlet match = null\n\twhile ((match = regularExpression.exec(derivationPath)) !== null) {\n\t\tconst hardened = match[1].lastIndexOf(`'`) !== -1\n\t\tconst index = Number.parseInt(hardened ? match[1].slice(0, -1) : match[1])\n\t\tresult.push({hardened, index})\n\t}\n\n\treturn result\n}\n\ninterface KeyChainPair {\n\tkey: bigint\n\tchainCode: Uint8Array\n}\n"]}