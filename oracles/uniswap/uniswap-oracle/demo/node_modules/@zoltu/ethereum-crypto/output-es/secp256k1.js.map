{"version":3,"file":"secp256k1.js","sourceRoot":"","sources":["../source/secp256k1.ts"],"names":[],"mappings":"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","sourcesContent":["import { bigintToBytes, modularMultiplicitiveInverse, bytesToBigint } from './utilities'\n\nexport interface AffinePoint {\n\t/** [0, 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f) */\n\tx: bigint\n\t/** [0, 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f) */\n\ty: bigint\n}\n\nexport interface JacobianPoint {\n\t/** [0, 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f) */\n\tx: bigint\n\t/** [0, 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f) */\n\ty: bigint\n\t/** [0, 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f) */\n\tz: bigint\n}\n\nexport interface Signature {\n\t/** [0, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141) */\n\tr: bigint\n\t/** [0, 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0) */\n\ts: bigint\n\trecoveryParameter: 0|1\n}\n\nexport const fieldModulus = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn as const\n// const b = 7n\nexport const basePoint: JacobianPoint = {\n\tx: 55066263022277343669578718895168534326250603453777594175500187360389116729240n,\n\ty: 32670510020758816978083085130507043184471273380659243275938904335757337482424n,\n\tz: 1n,\n} as const\nexport const basePointOrder = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141n as const\n// const h = 1n\n\n/**\n * Generates a random valid private key for usage is secp256k1 signing.\n */\nexport async function generatePrivateKey(): Promise<bigint> {\n\tlet result = 2n**256n\n\twhile (result >= basePointOrder || result <= 0) {\n\t\tresult = bytesToBigint(crypto.getRandomValues(new Uint8Array(32)))\n\t}\n\tvalidatePrivateKey(result)\n\treturn result\n}\n\n/**\n * Derives the public key that corresponds to {privateKey}.\n * @param privateKey A valid secp256k1 private key.  Usually a random number. Must be in the range (0, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141).\n */\nexport async function privateKeyToPublicKey(privateKey: bigint): Promise<JacobianPoint & AffinePoint> {\n\tprivateKey = (typeof privateKey === 'bigint') ? privateKey : bytesToBigint(privateKey)\n\tvalidatePrivateKey(privateKey)\n\t// we convert to affine and back to jacobian because that will result in getting a public key out that is compatible with both jacobian or affine systems, while the original jacobian key may only be compatible with jacobian processing\n\tconst jacobianPublicKey = pointMultiply(basePoint, privateKey)\n\tconst affinePublicKey = jacobianToAffine(jacobianPublicKey)\n\treturn affineToJacobian(affinePublicKey)\n}\n\nexport function encodePoint(point: JacobianPoint | AffinePoint): Uint8Array & { length: 65 } {\n\tconst affinePoint = ('z' in point) ? jacobianToAffine(point) : point\n\tconst result = [4]\n\tfor (let i = 0n; i < 32n; ++i) {\n\t\tresult.push(Number((affinePoint.x >> 248n - 8n * i) & 0xffn))\n\t}\n\tfor (let i = 0n; i < 32n; ++i) {\n\t\tresult.push(Number((affinePoint.y >> 248n - 8n * i) & 0xffn))\n\t}\n\treturn new Uint8Array(result) as Uint8Array & { length: 65 }\n}\n\nexport function encodePointCompressed(point: JacobianPoint | AffinePoint): Uint8Array & {length:33} {\n\tconst affinePoint = ('z' in point) ? jacobianToAffine(point) : point\n\treturn new Uint8Array([(affinePoint.y % 2n) ? 0x03 : 0x02, ...bigintToBytes(affinePoint.x, 32)]) as Uint8Array & {length:33}\n}\n\nexport function decodePoint(encoded: ArrayLike<number> & { length: 65 }): JacobianPoint & AffinePoint {\n\tif (encoded[0] !== 4) throw new Error(`This is not an encoded point.  Perhaps you have a compressed point?\\n${encoded}`)\n\tlet x = 0n\n\tfor (let i = 1; i <= 32; ++i) {\n\t\tconst shift = ((32n - BigInt(i)) * 8n)\n\t\tx |= BigInt(encoded[i]) << shift\n\t}\n\tlet y = 0n\n\tfor (let i = 1; i <= 32; ++i) {\n\t\tconst shift = ((32n - BigInt(i)) * 8n)\n\t\ty |= BigInt(encoded[i + 32]) << shift\n\t}\n\treturn affineToJacobian({ x, y })\n}\n\n/**\n * Sign {messageHash} with {privateKey}.  {messageHash} is usually the output of a hashing function (e.g., keccak256) run against some data that you wish to sign.\n * @param privateKey The private key you wish to sign with.  Usually a randomly generated 256-bit number.  Note that the valid range of values is actually constrained to (0, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141)\n * @param messageHash The 256-bit number you wish to sign.  Usually this is the output of a hashing function like keccak256. [0, 2**256)\n */\nexport async function sign(privateKey: bigint, messageHash: bigint): Promise<Signature> {\n\tvalidateMessageHash(messageHash)\n\tvalidatePrivateKey(privateKey)\n\tlet r = 0n\n\tlet s = 0n\n\tlet recoveryParameter: 0|1 = 0\n\tlet nonce = 0n\n\twhile (r === 0n || s === 0n) {\n\t\tnonce = await generateDeterministicSigningNonce(privateKey, messageHash)\n\t\tconst point = jacobianToAffine(pointMultiply(basePoint, nonce))\n\t\t// ethereum specific case, in bitcoin `r = point.x % basePointOrder` and point.x being larger than basePointOrder is encoded as part of the `recoveryParameter`.\n\t\tif (point.x >= basePointOrder) continue\n\t\tr = point.x\n\t\ts = modularMultiplicitiveInverse(nonce, basePointOrder) * (messageHash + r * privateKey) % basePointOrder\n\t\tlet yIsOdd = !!(point.y % 2n)\n\t\t// if there are multiple valid values of s, prefer the smaller one\n\t\tif (s >= basePointOrder / 2n) {\n\t\t\ts = basePointOrder - s\n\t\t\tyIsOdd = !yIsOdd // not sure why this is necessary, but it is...\n\t\t}\n\t\trecoveryParameter = Number(yIsOdd) as 0|1\n\t}\n\treturn { r, s, recoveryParameter }\n}\n\n/**\n * Verify that {signature} is the result of signing {messageHash} with the private key corresponding to {publicKey}.\n * @param publicKey The secp256k1 public key cooresponding to the private key that signed messageHash.\n * @param messageHash The 256-bit number that was signed.  Usually this is the output of a hashing function like keccak256. [0, 2**256)\n * @param signature The signature output from signing with the private key cooresponding to {publicKey} parameter\n */\nexport async function verify(publicKey: JacobianPoint | AffinePoint, messageHash: bigint, signature: Omit<Signature, 'recoveryParameter'>): Promise<boolean> {\n\tvalidateMessageHash(messageHash)\n\tconst affinePublicKey = ('z' in publicKey) ? jacobianToAffine(publicKey) : publicKey\n\tconst jacobianPublicKey = ('z' in publicKey) ? publicKey : affineToJacobian(publicKey)\n\t// verify it isn't the point at infinity\n\tif (isAtInfinity(jacobianPublicKey)) return false\n\t// verify the point is on the curve y^2 = x^3 + 7 (the secp256k1 curve)\n\tif ((affinePublicKey.x ** 3n + 7n) % fieldModulus !== (affinePublicKey.y ** 2n) % fieldModulus) return false\n\t// verify that the base point order times the point is the point at infinity\n\tconst expectedInfinitePoint = pointMultiply(jacobianPublicKey, basePointOrder)\n\tif (!isAtInfinity(expectedInfinitePoint)) return false\n\t// verify r is in the proper range\n\tconst signatureR = signature.r\n\tif (signatureR <= 0) return false\n\tif (signatureR >= basePointOrder) return false\n\t// verify s is in the proper range\n\tconst signatureS = signature.s\n\tif (signatureS <= 0) return false\n\tif (signatureS >= basePointOrder) return false\n\n\t// verify the signature\n\tconst inverseS = modularMultiplicitiveInverse(signatureS, basePointOrder)\n\tconst u1 = messageHash * inverseS % basePointOrder\n\tconst u2 = signatureR * inverseS % basePointOrder\n\tconst calculatedPoint = pointAdd(pointMultiply(basePoint, u1), pointMultiply(jacobianPublicKey, u2))\n\tif (isAtInfinity(calculatedPoint)) return false\n\tif (jacobianToAffine(calculatedPoint).x !== signatureR) return false\n\n\t// all of the checks for validity passed, thus the signature is valid\n\treturn true\n}\n\nasync function generateDeterministicSigningNonce(privateKey: bigint, messageHash: bigint): Promise<bigint> {\n\tconst privateKeyBytes = bigintToBytes(privateKey, 32)\n\tconst messageHashBytes = bigintToBytes(messageHash, 32)\n\tlet v = new Uint8Array(32).fill(1) as Uint8Array & {length:32}\n\tlet k = new Uint8Array(32).fill(0) as Uint8Array & {length:32}\n\tk = await hmac(k, [...v, 0, ...privateKeyBytes, ...messageHashBytes])\n\tv = await hmac(k, v)\n\tk = await hmac(k, [...v, 1,  ...privateKeyBytes, ...messageHashBytes])\n\tv = await hmac(k, v)\n\n\twhile (true) {\n\t\tv = await hmac(k, v)\n\t\tconst nonce = bytesToBigint(v)\n\t\tif (nonce >= 1n && nonce < basePointOrder) return nonce\n\t\tk = await hmac(k, [...v, 0])\n\t\tv = await hmac(k, v)\n\t}\n}\n\nasync function hmac(key: Uint8Array & {length:32}, data: Iterable<number>): Promise<Uint8Array & {length:32}> {\n\tconst cryptoKey = await crypto.subtle.importKey('raw', key, {name:'HMAC', hash:'SHA-256'}, false, ['sign'])\n\tconst signature = await crypto.subtle.sign('HMAC', cryptoKey, new Uint8Array(data))\n\treturn new Uint8Array(signature) as Uint8Array & {length:32}\n}\n\nfunction validatePrivateKey(privateKey: bigint): void {\n\tif (privateKey < 1) throw new Error(`Illegal private key.  Must be in range [1, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364140]`)\n\tif (privateKey >= basePointOrder) throw new Error(`Illegal private key.  Must be in range [1, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141)`)\n}\n\nfunction validateMessageHash(messageHash: bigint): void {\n\tif (messageHash < 0) throw new Error(`Message hash must be a positive number.`)\n\tif (messageHash >= 2n ** 256n) throw new Error(`Message hash is too big.  It must be a 256-bit number.`)\n}\n\nfunction pointMultiply(point: JacobianPoint, scalar: bigint): JacobianPoint {\n\t// https://en.wikipedia.org/wiki/Exponentiation_by_squaring (aka: double-and-add)\n\tlet result: JacobianPoint = {x: 1n, y: 1n, z: 0n}\n\tfor (let i = 0n; i < 256n; ++i) {\n\t\tresult = pointDouble(result)\n\t\tconst bit = !!((scalar >> 255n - i) & 0b1n)\n\t\tif (bit) result = pointAdd(result, point)\n\t}\n\treturn normalizePointInField(result)\n}\n\nfunction pointAdd(first: JacobianPoint, second: JacobianPoint): JacobianPoint {\n\t// http://www.hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#addition-add-2007-bl\n\tif (isAtInfinity(first)) return second\n\tif (isAtInfinity(second)) return first\n\n\tconst firstZSquared = first.z * first.z % fieldModulus\n\tconst secondZSquared = second.z * second.z % fieldModulus\n\tconst u1 = first.x * secondZSquared % fieldModulus\n\tconst u2 = second.x * firstZSquared % fieldModulus\n\tconst s1 = first.y * second.z * secondZSquared % fieldModulus\n\tconst s2 = second.y * first.z * firstZSquared % fieldModulus\n\tif (u1 === u2) {\n\t\tif (s1 === s2) return pointDouble(first)\n\t\telse return { x: 1n, y: 1n, z: 0n }\n\t}\n\tconst h = (u2 - u1) % fieldModulus\n\tconst i = (2n * h)**2n % fieldModulus\n\tconst j = h * i % fieldModulus\n\tconst r = 2n * (s2 - s1) % fieldModulus\n\tconst v = u1 * i % fieldModulus\n\tconst x = (r * r - j - 2n * v) % fieldModulus\n\tconst y = (r * (v - x) - 2n * s1 * j) % fieldModulus\n\tconst z = ((first.z + second.z)**2n - firstZSquared - secondZSquared) * h % fieldModulus\n\treturn { x, y, z }\n}\n\nfunction pointDouble(point: JacobianPoint): JacobianPoint {\n\tconst xSquared = point.x * point.x % fieldModulus\n\tconst ySquared = point.y * point.y % fieldModulus\n\tconst yQuarted = ySquared * ySquared % fieldModulus\n\tconst d = 2n * ((point.x + ySquared)**2n - xSquared - yQuarted) % fieldModulus\n\tconst e = 3n * xSquared % fieldModulus\n\tconst f = e**2n % fieldModulus\n\tconst x = (f - 2n * d) % fieldModulus\n\tconst y = (e * (d - x) - 8n * yQuarted) % fieldModulus\n\tconst z = 2n * point.y * point.z % fieldModulus\n\treturn { x, y, z }\n}\n\nfunction isAtInfinity(point: JacobianPoint | AffinePoint): boolean {\n\tif ('z' in point) {\n\t\tif (point.z !== 0n) return false\n\t\tif (point.x ** 3n % fieldModulus !== point.y ** 2n % fieldModulus) return false\n\t\treturn true\n\t} else {\n\t\tif (point.x !== 0n) return false\n\t\tif (point.y !== 0n) return false\n\t\treturn true\n\t}\n}\n\nfunction affineToJacobian(affine: AffinePoint): JacobianPoint {\n\tif (isAtInfinity(affine)) return { x: 1n, y: 1n, z: 0n }\n\treturn {\n\t\tx: affine.x,\n\t\ty: affine.y,\n\t\tz: 1n\n\t}\n}\n\nfunction jacobianToAffine(jacobian: JacobianPoint): AffinePoint {\n\tif (isAtInfinity(jacobian)) return { x: 0n, y: 0n }\n\tif (jacobian.z === 1n) return { x: jacobian.x, y: jacobian.y }\n\tconst zInverse = modularMultiplicitiveInverse(jacobian.z, fieldModulus)\n\treturn {\n\t\tx: jacobian.x * zInverse ** 2n % fieldModulus,\n\t\ty: jacobian.y * zInverse ** 3n % fieldModulus,\n\t}\n}\n\nfunction normalizePointInField(point: JacobianPoint): JacobianPoint\nfunction normalizePointInField(point: AffinePoint): AffinePoint\nfunction normalizePointInField(point: JacobianPoint | AffinePoint): JacobianPoint | AffinePoint {\n\tconst x = normalizeScalarInField(point.x)\n\tconst y = normalizeScalarInField(point.y)\n\tif ('z' in point) {\n\t\tconst z = normalizeScalarInField(point.z)\n\t\treturn { x, y, z }\n\t} else {\n\t\treturn { x, y }\n\t}\n}\n\nfunction normalizeScalarInField(value: bigint): bigint {\n\tif (value >= fieldModulus) return value % fieldModulus\n\tif (value < 0n) return normalizeScalarInField(value + fieldModulus)\n\treturn value\n}\n\n/**\n * These are here for reference.  They are nearly the most simple implementation of secp256k1 point add/point multiply functions.  The only optimization they have is that they use double and add for multiplication rather than adding a number 2**256 times in a loop (which is impossible on modern computers).  While they code is not used since using Jacobian coordinates are about 30x faster, I'm leaving it in here for reference in case some future reader wants to understand what is happening under the hood a litle better.\n */\n\n// function pointAdd(first: AffinePoint, second: AffinePoint): AffinePoint {\n// \t// if one of the points is the infinite point, then return the other\n// \tif (first.x === 0n && first.y === 0n) return second\n// \tif (second.x === 0n && second.y === 0n) return first\n// \t// if both points are the same, we can use the doubling formula (adding a point to itself doesn't work)\n// \tif (first.x === second.x && first.y === second.y) return pointDouble(first)\n// \t// if one point is the negation of the other, then return the infinite point\n// \tif (first.x === second.x && first.y === first.y * -1n + fieldModulus) return { x:0n, y:0n }\n// \t// if x is the same but y is different then it means we are adding a point to its negation, in which case the result is the point at infinity\n// \tif (first.x === second.x) return {x:0n, y:0n}\n// \tconst slope = div(sub(second.y, first.y), sub(second.x, first.x))\n// \tconst resultX = sub(sub(slope * slope, first.x), second.x)\n// \tconst resultY = sub(slope * sub(first.x, resultX), first.y)\n// \treturn { x: resultX % fieldModulus, y: resultY % fieldModulus }\n// }\n\n// function pointDouble(point: AffinePoint): AffinePoint {\n// \tif (point.x === 0n && point.y === 0n) return point\n// \tif (point.y + point.y === 0n) return {x:0n, y:0n}\n// \tconst slope = div(3n * point.x * point.x, 2n * point.y)\n// \tconst resultX = sub(sub(slope * slope, point.x), point.x)\n// \tconst resultY = sub(slope * sub(point.x, resultX), point.y)\n// \treturn { x: resultX % fieldModulus, y: resultY % fieldModulus }\n// }\n\n// function sub(minuend: bigint, subtrahend: bigint): bigint {\n// \treturn modularSubtract(minuend, subtrahend, fieldModulus)\n// }\n\n// function div(dividend: bigint, divisor: bigint): bigint {\n// \treturn modularDivide(dividend, divisor, fieldModulus)\n// }\n"]}