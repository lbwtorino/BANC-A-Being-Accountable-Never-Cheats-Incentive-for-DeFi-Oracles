{"version":3,"file":"index.js","sourceRoot":"","sources":["../source/index.ts"],"names":[],"mappings":"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","sourcesContent":["export type Encodable = EncodablePrimitive | EncodableTuple | EncodableArray\nexport type EncodablePrimitive = Uint8Array | string | boolean | bigint;\nexport interface EncodableTuple { [x: string]: Encodable }\nexport interface EncodableArray extends ReadonlyArray<Encodable> {}\n\nexport interface FunctionDescription {\n\treadonly type?: 'function'\n\treadonly name: string\n\treadonly inputs: ReadonlyArray<ParameterDescription>\n\treadonly outputs?: ReadonlyArray<ParameterDescription>\n\treadonly stateMutability?: 'pure' | 'view' | 'nonpayable' | 'payable'\n}\n\nexport interface EventDescription {\n\treadonly type: 'event'\n\treadonly name: string\n\treadonly inputs: ReadonlyArray<EventParameterDescription>\n\treadonly anonymous?: boolean\n}\n\nexport interface ConstructorDescription {\n\treadonly type: 'constructor'\n\treadonly inputs?: ReadonlyArray<ParameterDescription>\n\treadonly stateMutability?: 'pure' | 'view' | 'nonpayable' | 'payable'\n}\n\nexport interface FallbackDescription {\n\treadonly type: 'fallback'\n\treadonly stateMutability?: 'pure' | 'view' | 'nonpayable' | 'payable'\n}\n\nexport type AbiDescription = FunctionDescription | EventDescription | ConstructorDescription | FallbackDescription\n\nexport interface ParameterDescription {\n\treadonly name: string\n\treadonly type: string\n\treadonly components?: ReadonlyArray<ParameterDescription>\n}\n\nexport interface EventParameterDescription extends ParameterDescription {\n\treadonly indexed: boolean\n}\n\nexport interface DecodedEvent {\n\treadonly name: string\n\treadonly parameters: EncodableTuple\n}\n\n\n// signature parsing\n\nexport function parseSignature(functionSignature: string): FunctionDescription {\n\tconst signatureMatcher = /^([a-zA-Z_][a-zA-Z0-9_]+)\\((.*)\\)$/\n\tconst matchedSignature = signatureMatcher.exec(functionSignature)\n\tif (matchedSignature === null) throw new Error(`${functionSignature} is not a valid Solidity function signature.`)\n\tconst name = matchedSignature[1]\n\tconst inputs = parseParameters(matchedSignature[2])\n\treturn { type: 'function', name, inputs, outputs: [] }\n}\n\nfunction parseParameters(functionParameters: string): Array<ParameterDescription> {\n\tconst parameters: Array<ParameterDescription> = []\n\tlet remainingParameters = functionParameters.trim()\n\twhile (remainingParameters.length !== 0) {\n\t\tlet {parameterDescription, remaining} = extractNextParameter(remainingParameters)\n\t\tremainingParameters = remaining\n\t\tparameters.push(parameterDescription)\n\t}\n\t// fill in any missing argument names\n\treturn parameters.map((x, i) => ({ ...x, name: x.name || `arg${i}` }))\n}\n\nfunction extractNextParameter(functionParameters: string): {parameterDescription: ParameterDescription, remaining: string} {\n\tlet nesting = 0\n\tlet typeAndName = ''\n\tfor (const character of functionParameters) {\n\t\t// walk until we reach either the end of the string or a comma outside of all parenthesis\n\t\tif (character === '(') ++nesting\n\t\tif (character === ')') --nesting\n\t\tif (nesting < 0) throw new Error(`${functionParameters} does not have matching number of open and close parenthesis`)\n\t\tif (nesting > 0) {\n\t\t\ttypeAndName += character\n\t\t\tcontinue\n\t\t}\n\t\tif (character === ',') break\n\t\ttypeAndName += character\n\t}\n\tconst typeAndNameMatch = /^\\s*(.+?)\\s*(?:\\s([a-zA-Z_][a-zA-Z0-9_]*))?\\s*$/.exec(typeAndName)\n\tif (typeAndNameMatch === null) throw new Error(`${typeAndNameMatch} is not a valid parameter/name pair.`)\n\tlet parameterType = typeAndNameMatch[1]\n\tlet components: Array<ParameterDescription> | undefined = undefined\n\tif (parameterType.startsWith('(')) {\n\t\tconst tupleTypes = parameterType.slice(1, parameterType.lastIndexOf(')'))\n\t\tparameterType = `tuple${parameterType.slice(tupleTypes.length + 2)}`\n\t\tcomponents = parseParameters(tupleTypes)\n\t}\n\tconst parameterName = typeAndNameMatch[2] || ''\n\tlet remaining = functionParameters.slice(typeAndName.length)\n\tif (remaining.startsWith(',')) remaining = remaining.slice(1)\n\tremaining = remaining.trim()\n\tconst parameterDescription: ParameterDescription = {\n\t\tname: parameterName,\n\t\ttype: parameterType,\n\t\tcomponents: components,\n\t}\n\treturn { parameterDescription, remaining }\n}\n\n\n// signature generation\n\nexport function generateFullSignature(functionDescription: FunctionDescription): string {\n\treturn `${functionDescription.name}(${toFullParameters(functionDescription.inputs)})`\n}\n\nexport function generateCanonicalSignature(functionDescription: FunctionDescription): string {\n\treturn `${functionDescription.name}(${toCanonicalParameters(functionDescription.inputs)})`\n}\n\nfunction toFullParameters(parameters: readonly ParameterDescription[]): string {\n\treturn parameters.map(toFullParameter).join(', ')\n}\n\nfunction toCanonicalParameters(parameters: ReadonlyArray<ParameterDescription>): string {\n\treturn parameters.map(toCanonicalParameter).join(',')\n}\n\nfunction toFullParameter(parameter: ParameterDescription): string {\n\tif (parameter.type.startsWith('tuple')) {\n\t\tif (parameter.components === undefined) throw new Error(`Encountered a 'tuple' type that had no components.  Did you mean to include an empty array?`)\n\t\treturn `(${toFullParameters(parameter.components)})${parameter.type.slice('tuple'.length)} ${parameter.name}`\n\t} else {\n\t\treturn `${parameter.type} ${parameter.name}`\n\t}\n}\n\nfunction toCanonicalParameter(parameter: ParameterDescription): string {\n\tif (parameter.type.startsWith('tuple')) {\n\t\tif (parameter.components === undefined) throw new Error(`Encountered a 'tuple' type that had no components.  Did you mean to include an empty array?`)\n\t\treturn `(${toCanonicalParameters(parameter.components)})${parameter.type.slice('tuple'.length)}`\n\t} else {\n\t\treturn parameter.type\n\t}\n}\n\n\n// decoding\n\nexport async function decodeMethod(keccak256: (message: Uint8Array) => Promise<bigint>, functionDescription: FunctionDescription, bytes: Uint8Array): Promise<EncodableTuple>\nexport async function decodeMethod(keccak256: (message: Uint8Array) => Promise<bigint>, functionSignature: string, bytes: Uint8Array): Promise<EncodableTuple>\nexport function decodeMethod(functionSelector: number, parameterDescriptions: ReadonlyArray<ParameterDescription>, bytes: Uint8Array): EncodableTuple\nexport function decodeMethod(first: ((message: Uint8Array) => Promise<bigint>) | number, second: FunctionDescription | string | ReadonlyArray<ParameterDescription> | Uint8Array, bytes: Uint8Array): Promise<EncodableTuple> | EncodableTuple {\n\tif (typeof first === 'number') return decodeMethodWithSelector(first, second as ReadonlyArray<ParameterDescription>, bytes)\n\telse if (typeof second === 'string') return decodeMethodWithSignature(first, second, bytes)\n\telse return decodeMethodWithDescription(first, second as FunctionDescription, bytes)\n}\n\nasync function decodeMethodWithDescription(keccak256: (message: Uint8Array) => Promise<bigint>, functionDescription: FunctionDescription, bytes: Uint8Array): Promise<EncodableTuple> {\n\tconst canonicalSignature = generateCanonicalSignature(functionDescription)\n\tconst canonicalSignatureHash = await keccak256(new TextEncoder().encode(canonicalSignature))\n\tconst functionSelector = canonicalSignatureHash >> 224n\n\treturn decodeMethodWithSelector(Number(functionSelector), functionDescription.inputs, bytes)\n}\n\nasync function decodeMethodWithSignature(keccak256: (message: Uint8Array) => Promise<bigint>, functionSignature: string, bytes: Uint8Array): Promise<EncodableTuple> {\n\tconst functionDescription = parseSignature(functionSignature)\n\treturn await decodeMethodWithDescription(keccak256, functionDescription, bytes)\n}\n\nfunction decodeMethodWithSelector(expectedSelector: number, parameterDescriptions: ReadonlyArray<ParameterDescription>, bytes: Uint8Array): EncodableTuple {\n\tconst actualSelector = bytesToInteger(bytes.slice(0, 4))\n\tif (BigInt(expectedSelector) !== actualSelector) throw new Error(`Function selector of provided encoded method (${actualSelector.toString(16).padStart(8,'0')}) doesn't match expected selector (${expectedSelector.toString(16).padStart(8,'0')}).`)\n\tbytes = bytes.slice(4)\n\treturn decodeParameters(parameterDescriptions, bytes)\n}\n\n\nexport function decodeParameters(descriptions: ReadonlyArray<ParameterDescription>, data: Uint8Array): EncodableTuple {\n\tlet offset = 0\n\tconst decoded: EncodableTuple = {}\n\tfor (let description of descriptions) {\n\t\tconst { result, consumed } = decodeParameter(description, data, offset)\n\t\toffset += consumed\n\t\t// it is possible that name is missing/null/empty string if there is only a single parameter, in which case we use the placeholder name 'result'\n\t\tdecoded[description.name || 'result'] = result\n\t}\n\treturn decoded\n}\n\nfunction decodeParameter(description: ParameterDescription, data: Uint8Array, offset: number): { result: Encodable, consumed: number } {\n\treturn tryDecodeFixedArray(description, data, offset)\n\t\t|| tryDecodeDynamicArray(description, data, offset)\n\t\t|| tryDecodeTuple(description, data, offset)\n\t\t|| tryDecodeDynamicBytes(description, data, offset)\n\t\t|| tryDecodeString(description, data, offset)\n\t\t|| tryDecodeBoolean(description, data, offset)\n\t\t|| tryDecodeNumber(description, data, offset)\n\t\t|| tryDecodeNumber(description, data, offset)\n\t\t|| tryDecodeAddress(description, data, offset)\n\t\t|| tryDecodeFixedBytes(description, data, offset)\n\t\t|| tryDecodeFixedPointNumber(description, data, offset)\n\t\t|| tryDecodeFunction(description, data, offset)\n\t\t|| function () { throw new Error(`Unsupported parameter type ${description.type}`) }()\n}\n\nfunction tryDecodeFixedArray(description: ParameterDescription, data: Uint8Array, offset: number): { result: EncodableArray, consumed: number } | null {\n\tconst match = /^(.*)\\[(\\d+)\\]$/.exec(description.type)\n\tif (match === null) return null\n\tconst subdescription = Object.assign({}, description, { type: match[1] })\n\tconst length = Number.parseInt(match[2], 10)\n\tif (isDynamic(subdescription)) {\n\t\tconst pointer = Number(bytesToInteger(data.subarray(offset, offset + 32)))\n\t\tconst result: Encodable[] = []\n\t\tlet consumed = 0\n\t\tfor (let i = 0; i < length; ++i) {\n\t\t\tconst { result: itemResult, consumed: itemConsumed } = decodeParameter(subdescription, data.subarray(pointer), consumed)\n\t\t\tconsumed += itemConsumed\n\t\t\tresult.push(itemResult)\n\t\t}\n\t\treturn { result, consumed }\n\t} else {\n\t\tconst result: Encodable[] = []\n\t\tlet consumed = 0\n\t\tfor (let i = 0; i < length; ++i) {\n\t\t\tconst { result: itemResult, consumed: itemConsumed } = decodeParameter(subdescription, data, offset + consumed)\n\t\t\tconsumed += itemConsumed\n\t\t\tresult.push(itemResult)\n\t\t}\n\t\treturn { result, consumed }\n\t}\n}\n\nfunction tryDecodeDynamicArray(description: ParameterDescription, data: Uint8Array, offset: number): { result: EncodableArray, consumed: number } | null {\n\tif (!description.type.endsWith('[]')) return null\n\tconst subtype = description.type.substring(0, description.type.length - 2)\n\tconst subdescription = Object.assign({}, description, { type: subtype })\n\tconst pointer = Number(bytesToInteger(data.subarray(offset, offset + 32)))\n\tconst length = Number(bytesToInteger(data.subarray(pointer, pointer + 32)))\n\tconst result: Encodable[] = []\n\tlet consumed = 0\n\tfor (let i = 0; i < length; ++i) {\n\t\tconst { result: itemResult, consumed: itemConsumed } = decodeParameter(subdescription, data.subarray(pointer + 32), consumed)\n\t\tconsumed += itemConsumed\n\t\tresult.push(itemResult)\n\t}\n\treturn { result, consumed: 32 }\n}\n\nfunction tryDecodeTuple(description: ParameterDescription, data: Uint8Array, offset: number): { result: EncodableTuple, consumed: number } | null {\n\tif (description.type !== 'tuple') return null\n\tconst result: EncodableTuple = {}\n\tlet consumed: number = 0\n\tif (description.components === undefined || description.components.length === 0) {\n\t} else if (anyIsDynamic(description.components)) {\n\t\tconst pointer = Number(bytesToInteger(data.subarray(offset, offset + 32)))\n\t\tfor (let component of description.components) {\n\t\t\tconst { result: componentResult, consumed: componentConsumed } = decodeParameter(component, data.subarray(pointer), consumed)\n\t\t\tconsumed += componentConsumed\n\t\t\tresult[component.name] = componentResult\n\t\t}\n\t\t// from the point of view of the caller, we only consumed 32 bytes (the pointer)\n\t\tconsumed = 32\n\t} else {\n\t\tfor (let component of description.components) {\n\t\t\tconst { result: componentResult, consumed: componentConsumed } = decodeParameter(component, data, offset + consumed)\n\t\t\tconsumed += componentConsumed\n\t\t\tresult[component.name] = componentResult\n\t\t}\n\t}\n\treturn { result, consumed }\n}\n\nfunction tryDecodeDynamicBytes(description: ParameterDescription, data: Uint8Array, offset: number): { result: Uint8Array, consumed: 32 } | null {\n\tif (description.type !== 'bytes') return null\n\tconst pointer = Number(bytesToInteger(data.subarray(offset, offset + 32)))\n\tconst length = Number(bytesToInteger(data.subarray(pointer, pointer + 32)))\n\tconst bytes = data.subarray(pointer + 32, pointer + 32 + length)\n\treturn { result: bytes, consumed: 32 }\n}\n\nfunction tryDecodeString(description: ParameterDescription, data: Uint8Array, offset: number): { result: string, consumed: 32 } | null {\n\tif (description.type !== 'string') return null\n\tconst pointer = Number(bytesToInteger(data.subarray(offset, offset + 32)))\n\tconst length = Number(bytesToInteger(data.subarray(pointer, pointer + 32)))\n\tconst bytes = data.subarray(pointer + 32, pointer + 32 + length)\n\tconst decoded = new TextDecoder().decode(bytes)\n\treturn { result: decoded, consumed: 32 }\n}\n\nfunction tryDecodeBoolean(description: ParameterDescription, data: Uint8Array, offset: number): { result: boolean, consumed: 32 } | null {\n\tif (description.type !== 'bool') return null\n\tconst bytes = data.subarray(offset, offset + 32)\n\tconst decoded = (bytesToInteger(bytes) === 0n) ? false : true\n\treturn { result: !!decoded, consumed: 32 }\n}\n\nfunction tryDecodeNumber(description: ParameterDescription, data: Uint8Array, offset: number): { result: bigint, consumed: 32 } | null {\n\tconst match = /^(u?)int(\\d*)$/.exec(description.type)\n\tif (match === null) return null\n\tconst size = Number.parseInt(match[2])\n\tif (size <= 0 || size > 256 || size % 8) return null\n\tconst signed = !match[1]\n\tconst bytes = data.subarray(offset, offset + 32)\n\tconst decoded = bytesToInteger(bytes, signed)\n\tif (!signed && decoded >= 2n**BigInt(size)) throw new Error(`Encoded number is bigger than the expected size.  Expected smaller than ${2n**BigInt(size)}, but decoded ${decoded}.`)\n\tif (signed && decoded >= 2n**BigInt(size-1)) throw new Error(`Encoded number is bigger than the expected size.  Expected smaller than ${2n**BigInt(size-1)}, but decoded ${decoded}.`)\n\tif (signed && decoded < -(2n**BigInt(size-1))) throw new Error(`Encoded number is bigger (negative) than the expected size.  Expected smaller (negative) than -${2n**BigInt(size-1)}, but decoded ${decoded}.`)\n\treturn { result: decoded, consumed: 32 }\n}\n\nfunction tryDecodeAddress(description: ParameterDescription, data: Uint8Array, offset: number): { result: bigint, consumed: 32 } | null {\n\tif (description.type !== 'address') return null\n\tconst bytes = data.subarray(offset, offset + 32)\n\tconst decoded = bytesToInteger(bytes)\n\tif (decoded >= 2n**160n) throw new Error(`Encoded value is bigger than the largest possible address.  Decoded value: 0x${decoded.toString(16)}.`)\n\treturn { result: decoded, consumed: 32 }\n}\n\nfunction tryDecodeFixedBytes(description: ParameterDescription, data: Uint8Array, offset: number): { result: bigint, consumed: 32} | null {\n\tconst match = /^bytes(\\d+)$/.exec(description.type)\n\tif (match === null) return null\n\tconst size = Number.parseInt(match[1])\n\tif (size < 1 || size > 32) throw new Error(`Can only decode fixed length bytes values between 1 and 32 bytes.  Receivede 'bytes${size}'.`)\n\tconst bytes = data.subarray(offset, offset + size)\n\tconst decoded = bytesToInteger(bytes)\n\tconst padding = data.subarray(offset + size, offset + 32)\n\tif (padding.some(x => x !== 0)) throw new Error(`Encoded value contains extraneous unexpected bytes.  Extraneous bytes: 0x${Array.from(padding).map(x=>x.toString(16).padStart(2,'0')).join('')}.`)\n\treturn { result: decoded, consumed: 32 }\n}\n\nfunction tryDecodeFixedPointNumber(description: ParameterDescription, _data: Uint8Array, _offset: number): never | null {\n\tif (!/^u?fixed\\d+x\\d+$/.test(description.type)) return null\n\tthrow new Error(`Encoding an EVM type ${description.type} is not supported`)\n}\n\nfunction tryDecodeFunction(description: ParameterDescription, _data: Uint8Array, _offset: number): never | null {\n\tif (description.type !== 'function') return null\n\tthrow new Error(`Decoding an EVM type ${description.type} is not supported`)\n}\n\n\n// encoding\n\nexport async function encodeMethod(keccak256: (message: Uint8Array) => Promise<bigint>, functionDescription: FunctionDescription, parameters: EncodableArray): Promise<Uint8Array>\nexport async function encodeMethod(keccak256: (message: Uint8Array) => Promise<bigint>, functionSignature: string, parameters: EncodableArray): Promise<Uint8Array>\nexport function encodeMethod(functionSelector: number, parameterDescriptions: ReadonlyArray<ParameterDescription>, parameters: EncodableArray): Uint8Array\nexport function encodeMethod(first: ((message: Uint8Array) => Promise<bigint>) | number, second: FunctionDescription | string | ReadonlyArray<ParameterDescription> | EncodableArray, parameters: EncodableArray): Promise<Uint8Array> | Uint8Array {\n\tif (typeof first === 'number') return encodeMethodWithSelector(first, second as ReadonlyArray<ParameterDescription>, parameters)\n\telse if (typeof second === 'string') return encodeMethodWithSignature(first, second, parameters)\n\telse return encodeMethodWithDescription(first, second as FunctionDescription, parameters)\n}\n\nasync function encodeMethodWithDescription(keccak256: (message: Uint8Array) => Promise<bigint>, functionDescription: FunctionDescription, parameters: EncodableArray): Promise<Uint8Array> {\n\tconst canonicalSignature = generateCanonicalSignature(functionDescription)\n\tconst canonicalSignatureHash = await keccak256(new TextEncoder().encode(canonicalSignature))\n\tconst functionSelector = canonicalSignatureHash >> 224n\n\treturn encodeMethod(Number(functionSelector), functionDescription.inputs, parameters)\n}\n\nasync function encodeMethodWithSignature(keccak256: (message: Uint8Array) => Promise<bigint>, functionSignature: string, parameters: EncodableArray): Promise<Uint8Array> {\n\tconst functionDescription = parseSignature(functionSignature)\n\treturn await encodeMethodWithDescription(keccak256, functionDescription, parameters)\n}\n\nfunction encodeMethodWithSelector(functionSelector: number, parameterDescriptions: ReadonlyArray<ParameterDescription>, parameters: EncodableArray): Uint8Array {\n\tconst encodedParameters = encodeParameters(parameterDescriptions, parameters)\n\treturn new Uint8Array([...integerToBytes(functionSelector, 4), ...encodedParameters])\n}\n\nexport function encodeParameters(descriptions: ReadonlyArray<ParameterDescription>, parameters: EncodableArray): Uint8Array {\n\tif (descriptions.length !== parameters.length) throw new Error(`Number of provided parameters (${parameters.length}) does not match number of expected parameters (${descriptions.length})`)\n\tconst encodedParameters = parameters.map((nestedParameter, index) => encodeParameter(descriptions[index], nestedParameter))\n\treturn encodeDynamicData(encodedParameters)\n}\n\nfunction encodeParameter(description: ParameterDescription, parameter: Encodable): { isDynamic: boolean, bytes: Uint8Array } {\n\treturn tryEncodeFixedArray(description, parameter)\n\t\t|| tryEncodeDynamicArray(description, parameter)\n\t\t|| tryEncodeTuple(description, parameter)\n\t\t|| tryEncodeDynamicBytes(description, parameter)\n\t\t|| tryEncodeString(description, parameter)\n\t\t|| tryEncodeBoolean(description, parameter)\n\t\t|| tryEncodeNumber(description, parameter)\n\t\t|| tryEncodeAddress(description, parameter)\n\t\t|| tryEncodeFixedBytes(description, parameter)\n\t\t|| tryEncodeFixedPointNumber(description)\n\t\t|| tryEncodeFunction(description)\n\t\t|| function () { throw new Error(`Unsupported parameter type ${description.type}`) }()\n}\n\nfunction tryEncodeFixedArray(description: ParameterDescription, parameter: Encodable): { isDynamic: boolean, bytes: Uint8Array } | null {\n\tconst match = /^(.*)\\[(\\d+)\\]$/.exec(description.type)\n\tif (match === null) return null\n\tconst size = Number.parseInt(match[2])\n\tif (!Array.isArray(parameter) || parameter.length !== size) throw new Error(`Can only encode a JavaScript 'array' of length ${size} into an EVM 'array' of length ${size}\\n${parameter}`)\n\tconst nestedDescription = Object.assign({}, description, { type: match[1] })\n\tconst encodedParameters = parameter.map(nestedParameter => encodeParameter(nestedDescription, nestedParameter))\n\tconst isDynamic = encodedParameters.some(x => x.isDynamic)\n\tif (isDynamic) {\n\t\treturn { isDynamic: isDynamic, bytes: encodeDynamicData(encodedParameters)}\n\t} else {\n\t\treturn { isDynamic: isDynamic, bytes: concatenateBytes(encodedParameters.map(x => x.bytes)) }\n\t}\n}\n\nfunction tryEncodeDynamicArray(description: ParameterDescription, parameter: Encodable): { isDynamic: true, bytes: Uint8Array } | null {\n\tif (!description.type.endsWith('[]')) return null\n\tif (!Array.isArray(parameter)) throw new Error(`Can only encode a JavaScript 'array' into an EVM 'array'\\n${parameter}`)\n\tconst nestedDescription = Object.assign({}, description, { type: description.type.substring(0, description.type.length - 2) })\n\tconst encodedParameters = parameter.map(nestedParameter => encodeParameter(nestedDescription, nestedParameter))\n\tconst lengthBytes = integerToBytes(encodedParameters.length)\n\treturn { isDynamic: true, bytes: concatenateBytes([lengthBytes, encodeDynamicData(encodedParameters)]) }\n}\n\nfunction tryEncodeTuple(description: ParameterDescription, parameter: Encodable): { isDynamic: boolean, bytes: Uint8Array } | null {\n\tif (description.type !== 'tuple') return null\n\tif (typeof parameter !== 'object') throw new Error(`Can only encode a JavaScript 'object' or a JavaScript array into an EVM 'tuple'\\n${parameter}`)\n\tif (description.components === undefined || description.components.length === 0) {\n\t\treturn { isDynamic: false, bytes: new Uint8Array(0) }\n\t} else {\n\t\tconst encodableTupleOrArray = parameter as EncodableTuple | EncodableArray\n\t\tconst encodedComponents = description.components.map((component, index) => {\n\t\t\tconst parameter = isEncodableArray(encodableTupleOrArray) ? encodableTupleOrArray[index] : encodableTupleOrArray[component.name]\n\t\t\treturn encodeParameter(component, parameter)\n\t\t})\n\t\tconst isDynamic = encodedComponents.some(x => x.isDynamic)\n\t\treturn { isDynamic: isDynamic, bytes: isDynamic ? encodeDynamicData(encodedComponents) : concatenateBytes(encodedComponents.map(x => x.bytes)) }\n\t}\n}\n\nfunction tryEncodeDynamicBytes(description: ParameterDescription, parameter: Encodable): { isDynamic: true, bytes: Uint8Array } | null {\n\tif (description.type !== 'bytes') return null\n\tif (!(parameter instanceof Uint8Array)) throw new Error(`Can only encode a JavaScript 'Uint8Array' into EVM 'bytes'\\n${parameter}`)\n\treturn { isDynamic: true, bytes: padAndLengthPrefix(parameter) }\n}\n\nfunction tryEncodeString(description: ParameterDescription, parameter: Encodable): { isDynamic: true, bytes: Uint8Array } | null {\n\tif (description.type !== 'string') return null\n\tif (typeof parameter !== 'string') throw new Error(`Can only encode a JavaScript 'string' into an EVM 'string'\\n${parameter}`)\n\tconst encoded = new TextEncoder().encode(parameter)\n\treturn { isDynamic: true, bytes: padAndLengthPrefix(encoded) }\n}\n\nfunction tryEncodeBoolean(description: ParameterDescription, parameter: Encodable): { isDynamic: false, bytes: Uint8Array } | null {\n\tif (description.type !== 'bool') return null\n\tif (typeof parameter !== 'boolean') throw new Error(`Can only encode JavaScript 'boolean' into EVM 'bool'\\n${parameter}`)\n\tconst bytes = new Uint8Array(32)\n\tbytes.set([parameter ? 1 : 0], 31)\n\treturn { isDynamic: false, bytes }\n}\n\nfunction tryEncodeNumber(description: ParameterDescription, parameter: Encodable): { isDynamic: false, bytes: Uint8Array } | null {\n\tconst match = /^(u?)int(\\d*)$/.exec(description.type)\n\tif (match === null) return null\n\tif (typeof parameter !== 'bigint') throw new Error(`Can only encode a JavaScript 'bigint' into an EVM '${description.type}'\\n${parameter}`)\n\tconst size = Number.parseInt(match[2])\n\tif (size <= 0 || size > 256 || size % 8) throw new Error(`EVM numbers must be in range [8, 256] and must be divisible by 8.`)\n\tconst signed = !match[1]\n\tif (!signed && parameter >= 2n**BigInt(size)) throw new Error(`Attempted to encode ${parameter} into a ${description.type}, but it is too big to fit.`)\n\tif (!signed && parameter < 0n) throw new Error(`Attempted to encode ${parameter} into a ${description.type}, but you cannot encode negative numbers into a ${description.type}.`)\n\tif (signed && parameter >= 2n**BigInt(size-1)) throw new Error(`Attempted to encode ${parameter} into a ${description.type}, but it is too big to fit.`)\n\tif (signed && parameter < -(2n**BigInt(size-1))) throw new Error(`Attempted to encode ${parameter} into a ${description.type}, but it is too big (of a negative number) to fit.`)\n\tconst bytes = integerToBytes(parameter, 32, signed)\n\treturn { isDynamic: false, bytes }\n}\n\nfunction tryEncodeAddress(description: ParameterDescription, parameter: Encodable): { isDynamic: false, bytes: Uint8Array } | null {\n\tif (description.type !== 'address') return null\n\tif (typeof parameter !== 'bigint') throw new Error(`Can only encode JavaScript 'bigint' into EVM 'address'\\n${parameter}`)\n\tif (parameter > 0xffffffffffffffffffffffffffffffffffffffffn) throw new Error(`Attempted to encode 0x${parameter.toString(16)} into an EVM address, but it is too big to fit.`)\n\tif (parameter < 0n) throw new Error(`Attempted to encode ${parameter} into an EVM address, but addresses must be positive numbers.`)\n\treturn { isDynamic: false, bytes: padLeftTo32Bytes(integerToBytes(parameter, 20)) }\n}\n\nfunction tryEncodeFixedBytes(description: ParameterDescription, parameter: Encodable): { isDynamic: false, bytes: Uint8Array } | null {\n\tconst match = /^bytes(\\d+)$/.exec(description.type)\n\tif (match === null) return null\n\tconst size = Number.parseInt(match[1])\n\tif (typeof parameter !== 'bigint') throw new Error(`Can only encode JavaScript 'bigint' into EVM 'bytes${size}'\\n${parameter}`)\n\tif (parameter >= 2n**BigInt(size * 8)) throw new Error(`Attempted to encode 0x${parameter.toString(16)} into an EVM ${description.type}, but it is too big to fit.`)\n\tif (parameter < 0n) throw new Error(`Attempted to encode -0x${parameter.toString(16).slice(1)} into an EVM ${description.type}, but you cannot encode negative numbers into a ${description.type}.`)\n\treturn { isDynamic: false, bytes: padRightTo32Bytes(integerToBytes(parameter, size)) }\n}\n\nfunction tryEncodeFixedPointNumber(description: ParameterDescription): { isDynamic: never, bytes: Uint8Array } | null {\n\tif (!/^u?fixed\\d+x\\d+$/.test(description.type)) return null\n\tthrow new Error(`Encoding into EVM type ${description.type} is not supported`)\n}\n\nfunction tryEncodeFunction(description: ParameterDescription): { isDynamic: never, bytes: Uint8Array } | null {\n\tif (description.type !== 'function') return null\n\tthrow new Error(`Encoding into EVM type ${description.type} is not supported`)\n}\n\n\n// events\n\nexport async function decodeUnknownEvent(keccak256: (message: Uint8Array) => Promise<bigint>, abi: ReadonlyArray<AbiDescription>, topics: ReadonlyArray<bigint>, data: Uint8Array): Promise<DecodedEvent> {\n\tfor (const eventDescription of abi) {\n\t\tif (!isEventDescription(eventDescription)) continue\n\t\tconst canonicalSignature = `${eventDescription.name}(${eventDescription.inputs.map(parameter => parameter.type).join(\",\")})`\n\t\tconst signatureHash = await keccak256(new TextEncoder().encode(canonicalSignature))\n\t\tif (topics[0] !== signatureHash) continue\n\t\treturn decodeEvent(eventDescription, topics, data)\n\t}\n\tthrow new Error(`No event description matched the event ${topics[0]}`)\n}\n\nexport function decodeEvent(eventDescription: EventDescription, topics: ReadonlyArray<bigint>, data: Uint8Array): DecodedEvent {\n\t// CONSIDER: should we take in a hash function so we can verify topics[0] matches, or just blindly extract?\n\tconst decodedParameters = decodeEventParameters(eventDescription.inputs, topics, data)\n\treturn { name: eventDescription.name, parameters: decodedParameters }\n}\n\nfunction decodeEventParameters(parameters: ReadonlyArray<EventParameterDescription>, topics: ReadonlyArray<bigint>, data: Uint8Array): EncodableTuple {\n\tconst indexedTypesForDecoding = parameters.filter(parameter => parameter.indexed).map(getTypeForEventDecoding)\n\tconst nonIndexedTypesForDecoding = parameters.filter(parameter => !parameter.indexed)\n\tconst indexedData = concatenateBytes(topics.slice(1).map(topic => integerToBytes(topic)))\n\tconst nonIndexedData = data\n\tconst decodedIndexedParameters = decodeParameters(indexedTypesForDecoding, indexedData)\n\tif (!decodedIndexedParameters) throw new Error(`Failed to decode topics for event ${topics[0]}.\\n${indexedData}`)\n\tconst decodedNonIndexedParameters = decodeParameters(nonIndexedTypesForDecoding, nonIndexedData)\n\tif (!decodedNonIndexedParameters) throw new Error(`Failed to decode data for event ${topics[0]}.\\n${nonIndexedData}`)\n\treturn Object.assign({}, decodedIndexedParameters, decodedNonIndexedParameters)\n}\n\nfunction getTypeForEventDecoding(parameter: EventParameterDescription): EventParameterDescription {\n\tif (!parameter.indexed) return parameter\n\tif (parameter.type !== 'string'\n\t\t&& parameter.type !== 'bytes'\n\t\t// TODO: check to see if we need to collapse fixed size tuples or not\n\t\t&& !parameter.type.startsWith('tuple')\n\t\t// TODO: check to see if we need to collapse fixed length arrays here or not\n\t\t&& !parameter.type.endsWith('[]'))\n\t\treturn parameter\n\treturn Object.assign({}, parameter, { type: 'bytes32' })\n}\n\nfunction isEventDescription(maybe: AbiDescription): maybe is EventDescription { return maybe.type === 'event' }\n\n\n// helpers\n\nfunction padLeftTo32Bytes(input: Uint8Array): Uint8Array {\n\tconst length = (input.length % 32)\n\t\t? input.length + 32 - input.length % 32\n\t\t: input.length\n\tconst result = new Uint8Array(length)\n\tresult.set(input, result.length - input.length)\n\treturn result\n}\n\nfunction padRightTo32Bytes(input: Uint8Array): Uint8Array {\n\tconst length = (input.length % 32)\n\t\t? input.length + 32 - input.length % 32\n\t\t: input.length\n\tconst result = new Uint8Array(length)\n\tresult.set(input, 0)\n\treturn result\n}\n\nfunction concatenateBytes(source: ReadonlyArray<Uint8Array>): Uint8Array {\n\treturn new Uint8Array(source.flatMap(x => [...x]))\n}\n\nfunction padAndLengthPrefix(source: Uint8Array): Uint8Array {\n\tconst length = source.length\n\tconst padded = padRightTo32Bytes(source)\n\treturn concatenateBytes([integerToBytes(length), padded])\n}\n\nfunction encodeDynamicData(encodedData: ReadonlyArray<{ isDynamic: boolean, bytes: Uint8Array }>): Uint8Array {\n\tlet staticBytesSize = 0\n\tfor (let encodedParameter of encodedData) {\n\t\tif (encodedParameter.isDynamic) staticBytesSize += 32\n\t\telse staticBytesSize += encodedParameter.bytes.length\n\t}\n\tconst staticBytes: Array<Uint8Array> = []\n\tconst dynamicBytes: Array<Uint8Array> = []\n\tfor (let encodedParameter of encodedData) {\n\t\tif (encodedParameter.isDynamic) {\n\t\t\tconst dynamicBytesAppendedSoFar = dynamicBytes.reduce((total, bytes) => total += bytes.length, 0)\n\t\t\tstaticBytes.push(integerToBytes(staticBytesSize + dynamicBytesAppendedSoFar))\n\t\t\tdynamicBytes.push(encodedParameter.bytes)\n\t\t} else {\n\t\t\tstaticBytes.push(encodedParameter.bytes)\n\t\t}\n\t}\n\treturn concatenateBytes([...staticBytes, ...dynamicBytes])\n}\n\nfunction anyIsDynamic(descriptions: ReadonlyArray<ParameterDescription>): boolean {\n\tfor (let description of descriptions) {\n\t\tif (isDynamic(description)) return true\n\t}\n\treturn false\n}\n\nfunction isDynamic(description: ParameterDescription): boolean {\n\tif (description.type === 'string') return true\n\tif (description.type === 'bytes') return true\n\tif (description.type.endsWith('[]')) return true\n\tconst fixedArrayMatcher = /^(.*)\\[(\\d+)\\]$/.exec(description.type)\n\tif (fixedArrayMatcher !== null && isDynamic(Object.assign({}, description, { type: fixedArrayMatcher[1] }))) return true\n\tif (description.type === 'tuple' && anyIsDynamic(description.components || [])) return true\n\treturn false\n}\n\nfunction isEncodableArray(maybe: EncodableArray | EncodableTuple): maybe is EncodableArray {\n\treturn Array.isArray(maybe)\n}\n\nfunction bytesToInteger(bytes: Uint8Array, signed = false): bigint {\n\treturn signed\n\t\t? bytesToSigned(bytes)\n\t\t: bytesToUnsigned(bytes)\n}\n\nfunction integerToBytes(value: bigint | number, byteWidth = 32, signed = false): Uint8Array {\n\treturn signed\n\t\t? signedToBytes(value, byteWidth)\n\t\t: unsignedToBytes(value, byteWidth)\n}\n\nfunction bytesToUnsigned(bytes: Uint8Array): bigint {\n\tlet value = 0n\n\tfor (let byte of bytes) {\n\t\tvalue = (value << 8n) + BigInt(byte)\n\t}\n\treturn value\n}\n\nfunction bytesToSigned(bytes: Uint8Array): bigint {\n\tconst unsignedValue = bytesToUnsigned(bytes)\n\treturn twosComplement(unsignedValue, bytes.length * 8)\n}\n\nfunction unsignedToBytes(value: bigint | number, byteWidth: number = 32): Uint8Array {\n\tif (typeof value === 'number') value = BigInt(value)\n\tconst bits = byteWidth * 8\n\tif (value >= 2n ** BigInt(bits) || value < 0n) throw new Error(`Cannot fit ${value} into a ${bits}-bit unsigned integer.`)\n\tconst result = new Uint8Array(byteWidth)\n\tfor (let i = 0; i < byteWidth; ++i) {\n\t\tresult[i] = Number((value >> BigInt(bits - i * 8 - 8)) & 0xffn)\n\t}\n\treturn result\n}\n\nfunction signedToBytes(value: bigint | number, byteWidth: number = 32): Uint8Array {\n\tif (typeof value === 'number') value = BigInt(value)\n\tconst bits = byteWidth * 8\n\tif (value >= 2n ** (BigInt(bits) - 1n) || value < -(2n ** (BigInt(bits) - 1n))) throw new Error(`Cannot fit ${value} into a ${bits}-bit signed integer.`)\n\tconst unsignedValue = twosComplement(value, bits)\n\treturn unsignedToBytes(unsignedValue)\n}\n\nfunction twosComplement(value: bigint, numberOfBits: number): bigint {\n\tconst mask = 2n ** (BigInt(numberOfBits) - 1n) - 1n\n\treturn (value & mask) - (value & ~mask)\n}\n\n// https://github.com/microsoft/TypeScript/issues/17002\ndeclare global {\n\tinterface ArrayConstructor {\n\t\tisArray(arg: ReadonlyArray<any> | any): arg is ReadonlyArray<any>\n\t}\n}\n"]}